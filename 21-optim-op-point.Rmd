# Optimal operating point on FROC {#optim-op-point}

---
output:
  rmarkdown::pdf_document:
    fig_caption: yes        
    includes:  
      in_header: R/learn/my_header.tex
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval.after = "fig.cap"
)

library(RJafroc)
library(ggplot2)
library(kableExtra)
library(gridExtra)
library(abind)
library(dplyr)
```



```{r, echo=FALSE}
OpPtStr <- function(x,y) {
  y <- paste0("(", sprintf("%.3f", x), ", ", sprintf("%.3f", y), ")")
  return(y)
}

simplePrint <- function(x) {
  sprintf("%.3f", x)
}
```



## TBA How much finished {#optim-op-point-how-much-finished}
80%

Discussion and Intro need more work; coding is done


## Introduction {#optim-op-point-intro}

This chapter deals with finding the optimal reporting threshold of an algorithmic observer, such as CAD/AI. We assume that designer level FROC data is available for the algorithm, i.e., the data consists of mark-rating pairs, with continuous-scale ratings, and a decision needs to be made as to the optimal reporting threshold, i.e., the minimum rating of a mark before it is shown to the radiologist. This is a familiar problem faced by a CAD/AI algorithm designer. 

The problem has been solved in the context of ROC analysis [@metz1978rocmethodology], namely, the optimal operating point on the ROC corresponds to a slope determined by disease prevalence and the cost of decisions in the four basic binary paradigm categories: true and false positives and true and false negatives. In practice the costs are difficult to quantify. However, for equal numbers of diseased and non-diseased cases and equal costs it can be shown that the slope of the ROC curve at the optimal point is unity. For a proper ROC curve this corresponds to the point that maximizes the Youden-index [@youden1950index], defined as the sum of sensitivity and specificity minus one. Typically it is maximized at the point that is closest to the (0,1) corner of the ROC. 

CAD/AI produces FROC data and lacking a procedure for setting it analytically, CAD/AI manufacturers, in consultation with radiologists, set site-specific reporting thresholds. For example, if radiologists at a site are comfortable with more false marks as the price of potentially greater lesion-level sensitivity, the reporting threshold for them is adjusted downward. 

This chapter describes an analytic method for finding the optimal reporting threshold. The method is based on maximizing AUC (area under curve) under the wAFROC curve. The method is compared to the Youden-index based method.   



## Methods {#optim-op-point-methods}

Terminology: 
Non-lesion localizations = NLs, i.e., location level "false positives".
Lesion localizations = LLs, i.e., location level "true positives".
Latent marks = perceived suspicious regions that are not necessarily marked.

Background on the radiological search model (RSM) is provided in Chapter \@ref(rsm). The model predicts ROC, FROC and wAFROC curves. These curves are completely defined by the RSM parameters -- $\lambda$, $\nu$, $\mu$ and $\zeta_1$ -- which have the following meanings:

* The $\mu$ parameter, $\mu \ge 0$, is the perceptual signal to noise ratio of lesions. Higher values of $\mu$ lead to increased separation of two unit variance normal distributions determining the ratings of perceived NLs and LL. As $\mu$ increases performance of the algorithm increases.

* The $\lambda$ parameter, $\lambda \ge 0$, determines the mean number of latent NLs per case. Higher values lead to more latent NL marks per case and decreased performance. 

* The $\nu$ parameter, $0 \le \nu \le 1$, determines the probability of latent LLs, i.e., the probability that any present lesion will be perceived. Higher values of $\nu$ lead to more latent LL marks and increased performance.  

* The $\zeta_1$ parameter determines if a suspicious region found by the algorithm is actually marked (if the z-sample exceeds $\zeta_1$ the latent mark becomes an actual mark). Higher values correspond to more stringent reporting criteria and fewer reported marks. Performance, as measured by wAFROC-AUC or the Youden-index, peaks at an optimal value of $\zeta_1$. The purpose of this chapter is to investigate this effect, i.e., given values of the other RSM parameters and the figure of merit to be optimized (i.e., wAFROC-AUC or the Youden-index), to determine the optimal value of $\zeta_1$.  


TBA (lay out rationale for following material) In the following sections each of the first three parameters is varied in turn and the corresponding optimal $\zeta_1$ determined by maximizing one of two figures of merit (FOMs), namely, the wAFROC-AUC and the Youden-index. The value maximizing wAFROC-AUC is denoted $\zeta_{1;1\mu \lambda \nu}$ and the value maximizing the Youden-index is denoted $\zeta_{2;\mu \lambda \nu}$. 


## Figures of merit to be maximized
The wAFROC figure of merit is implemented in the `RJafroc` function `UtilAnalyticalAucsRSM`. It was assumed that half of the diseased cases contain one lesion and the rest contain two lesions and the lesions are assigned equal weights (i.e., clinical importance).

The Youden-index is defined as the sum of sensitivity and specificity minus 1. Sensitivity is implemented in function `RSM_yROC` and specificity is `(1 - RSM_xROC)`. 


```{r foms_2be_maximized, echo=FALSE, attr.source = ".numberLines"}

wAFROC <- function (
  zeta1, mu, lambdaP, nuP, 
  lesDistr, 
  relWeights) {
  # return negative of aucwAFROC 
  # (as optimize finds minimum of function)
  return(-UtilAnalyticalAucsRSM(
    mu, 
    lambdaP = lambdaP, 
    nuP = nuP, 
    zeta1, 
    lesDistr, 
    relWeights)$aucwAFROC)
  
}


Youden <- function (
  zeta1, 
  mu, 
  lambdaP, 
  nuP, 
  lesDistr, 
  relWeights) {
  # add sensitivity and specificity 
  # and subtract 1, i.e., Youden's index
  x <- RSM_yROC(
    zeta1, 
    mu, 
    lambdaP, 
    nuP, 
    lesDistr) + 
    (1 - RSM_xROC(zeta1, lambdaP)) - 1
  # return negative of Youden-index 
  # (as optimize finds minimum of function)
  return(-x)
  
}
```


## Optimizations involving varying $\lambda$  {#optim-op-point-vary-lambda}

For $\mu = 2$ and $\nu = 0.9$ optimizations were performed for $\lambda = 1, 2, 5, 10$. The following quantities were calculated:

* $\zeta_{1;1\mu \lambda \nu}$, the optimal thresholds for wAFROC based optimizations and $\zeta_{1;2\mu \lambda \nu}$ for Youden-index based optimizations;
* $\text{wAFROC} \left (1\mu \lambda \nu \right )$, the optimal value of the wAFROC-AUC for wAFROC based optimizations; 
* $\text{wAFROC} \left (2\mu \lambda \nu \right )$, the optimal value of the wAFROC-AUC for Youden-index based optimizations. For consistency we always report wAFROC-AUC even when the optimized quantity is the Youden-index;
* $\text{ROC} \left (1\mu \lambda \nu \right )$, the AUCs under the ROC curves for wAFROC based optimizations;   
* $\text{ROC} \left (2\mu \lambda \nu \right )$, the AUCs under the ROC curves for Youden-index based optimizations;   
* $\text{NLF} \left (1\mu \lambda \nu \right )$ and $\text{LLF} \left (1\mu \lambda \nu \right )$: the coordinates of the optimal operating points on the FROC curve for wAFROC based optimizations;   
* $\text{NLF} \left (2\mu \lambda \nu \right )$ and $\text{LLF} \left (2\mu \lambda \nu \right )$: the coordinates of the optimal operating points on the FROC curve for Youden-index based optimizations.   


Table \@ref(tab:optim-op-point-table-vary-lambda) summarizes these results. The column labeled FOM shows the quantity being maximized, $\lambda$ corresponds to the 4 values of $\lambda$, $\zeta_1$ is the optimal value of $\zeta_1$ that maximizes the chosen figure of merit. All quantities in columns 3 through 6 are functions of $x\mu \lambda \nu$, where x = 1 for wAFROC and x = 2 for Youden-index. The column labeled wAFROC is the AUC under the wAFROC curve, the column labeled ROC is the AUC under the ROC curve, and $\left( \text{NLF}, \text{LLF}\right)$ is the optimal operating point on the FROC curve. 



```{r optim-op-point-computations-lambda, cache = FALSE, echo=FALSE, attr.source = ".numberLines"}
mu <- 2
nuP <- 0.9
lambdaPArr <- c(1, 2, 5,10)
wAfrocArr <- array(dim = c(2,length(lambdaPArr)))
zetaOptArr <- array(dim = c(2,length(lambdaPArr)))
rocArr <- array(dim = c(2,length(lambdaPArr)))
nlfOptArr <- array(dim = c(2,length(lambdaPArr)))
llfOptArr <- array(dim = c(2,length(lambdaPArr)))
lesDistr <- c(0.5, 0.5)
relWeights <- c(0.5, 0.5)
for (y in 1:2) {
  for (i in 1:length(lambdaPArr)) {
    lambdaP <- lambdaPArr[i]
    if (y == 1) {
      x <- optimize(wAFROC, 
                    interval = c(-5,5), 
                    mu, 
                    lambdaP = lambdaP, 
                    nuP = nuP, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      wAfrocArr[y,i] <- -x$objective # safe to use objective here
      rocArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambdaP = lambdaP, 
        nuP = nuP, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        lambdaP = lambdaP)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, 
        mu, 
        nuP = nuP)
    } else if (y == 2) {
      x <- optimize(Youden, 
                    interval = c(-5,5), 
                    mu, 
                    lambdaP = lambdaP, 
                    nuP = nuP, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      wAfrocArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambdaP = lambdaP, 
        nuP = nuP, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucwAFROC
      rocArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambdaP = lambdaP, 
        nuP = nuP, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        lambdaP = lambdaP)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, mu, nuP)
    } else stop("incorrect y")
  }
}
```





```{r optim-op-point-table-vary-lambda-contents, echo=FALSE}
x1 <- cbind(rep("wAFROC",4), lambda = lambdaPArr, zeta1 = simplePrint(zetaOptArr[1,]), wAFROC = simplePrint(wAfrocArr[1,]), ROC = simplePrint(rocArr[1,]), OptOpPt = OpPtStr(nlfOptArr[1,], llfOptArr[1,]))
x2 <- cbind(rep("Youden",4), lambda = lambdaPArr, zeta1 = simplePrint(zetaOptArr[2,]), wAFROC = simplePrint(wAfrocArr[2,]), ROC = simplePrint(rocArr[2,]), OptOpPt = OpPtStr(nlfOptArr[2,], llfOptArr[2,]))
x12 <- as.data.frame(rbind(x1,x2))
colnames(x12) <- c("FOM", "$\\lambda$", "$\\zeta_1$", "$\\text{wAFROC}$", "$\\text{ROC}$", "$\\left( \\text{NLF}, \\text{LLF}\\right)$")
```



```{r optim-op-point-table-vary-lambda, echo=FALSE}
kbl(x12, caption = "Summary of optimization results for $\\mu = 2$, $\\nu = 0.9$ and 4 values of $\\lambda$.", booktabs = TRUE, escape = FALSE) %>% collapse_rows(columns = c(1), valign = "middle") %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```


The $\lambda$ parameter controls the average number of perceived NLs per case. For $\lambda = 1$ there is, on average, one perceived NL for every non-diseased case and the optimal wAFROC-based threshold is $\zeta_{1;1,\mu, \lambda = 1, \nu}$ = `r simplePrint(zetaOptArr[1,1])`. For $\lambda = 10$ there are ten perceived NLs for every non-diseased case and the optimal wAFROC-based threshold is $\zeta_{1;1,\mu, \lambda = 10, \nu}$ = `r simplePrint(zetaOptArr[1,4])`. The increase in $\zeta_1$ effect should be familiar to CAD/AI algorithm designers: with increasing numbers of NLs per case it is necessary to increase the reporting threshold (i.e., adopt a stricter reporting criteria). Also, overall CAD/AI performance decreases, regardless of how it is measured (i.e., wAFROC-AUC or ROC-AUC) and the optimal operating point on the FROC, $\left( \text{NLF}, \text{LLF}\right)$, moves down the curve.   


With larger $\lambda$ overall optimized performance is expected to be lower as confirmed by the corresponding wAFROC-AUC and ROC-AUC values. This is due to two reinforcing effects: performance goes down with increasing numbers of NLs per case and performance goes down with increasing reporting threshold. 

While these effects are also true for the Youden-index based optimizations, the optimal thresholds are collectively higher than the corresponding wAFROC based optimizations, especially for the lower values of $\lambda$: $\zeta_{1;2,\mu, \lambda = 1, \nu}$ = `r simplePrint(zetaOptArr[2,1])` and $\zeta_{1;2,\mu, \lambda = 10, \nu}$ = `r simplePrint(zetaOptArr[2,4])`. This results in lower wAFROC-AUC and ROC-AUC values when using Youden-index based optimizations.

The ROC-AUCs are reported as a check of the less familar wAFROC-AUC figure of merit. It is evident that the ordering of the two optimization methods is independent of whether it is measured via the wAFROC-AUC or the ROC-AUC: either way the wAFROC-AUC based optimizations yield higher AUC values and higher operating points on the FROC than the corresponding Youden-index based optimizations.   


### Illustrative FROC plots

TBA


```{r, attr.source = ".numberLines", echo=FALSE}
plotArr <- array(list(), dim = 4)
for (i in 1:4) {
  z <- seq(-5,mu+5,0.1)
  lambdaP <- lambdaPArr[i]
  xFROC <- RSM_xFROC(z, lambdaP)
  yFROC <- RSM_yFROC(z, mu, nuP)
  df_froc <- data.frame(
    NLF = xFROC, 
    LLF = yFROC)
  plotArr[[i]] <- ggplot2::ggplot(
    df_froc, 
    aes(x = NLF, y = LLF)) + 
    geom_line() +
    scale_x_continuous(limits = c(0,lambdaPArr[i])) + 
    scale_y_continuous(limits = c(0,1))
  for (y in 1:2) {
    optPt <- data.frame(
      NLF = nlfOptArr[y,i], 
      LLF = llfOptArr[y,i])
    plotArr[[i]] <- plotArr[[i]] + 
      geom_point(data = optPt, color = y) + 
    ggtitle(paste0("mu = ", mu, ", nu = ", nuP, ", lambda = ", lambdaPArr[i]))
  }
}
```




```{r optim-op-point-vary-lambda-froc, fig.cap = "FROC plots with superimposed operating points for varying $\\lambda$. The black dot is when maximized wAFROC AUC was used to find the optimal operating point and red dot is when maximized Youden-index was used.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
```




TBA These plots illustrate the previous comments, namely, as $\lambda$ increases, the optimal operating point moves *down* the scaled curve corresponding to adoption of progressively more stringent reporting thresholds.

TBA The right panel shows the optimal operating point when the Youden-index is maximized. It has the same general features as the previous example but, taken as a whole, the group of four operating points in the right panel are below-left those in the left panel, representing higher values of optimal $\zeta_1$, i.e., more stringent reporting criteria. As seen in Table \@ref(tab:optim-op-point-table-vary-lambda) the overly strict criteria resulting from using Youden-index based optimizations, lead to lower true performance: i.e., lower wAFROC-AUC and lower ROC-AUC. It also yields lower values of $\text{LLF}$, i.e., fewer correctly localized lesions.


### Illustrative wAFROC plots



```{r, attr.source = ".numberLines", echo=FALSE}
plotArr <- array(list(), dim = 4)
for (i in 1:4) {
  x <- UtilPhysical2IntrinsicRSM(mu, lambdaP = lambdaPArr[i], nuP = nuP)
  lambda <- x$lambda
  nu <- x$nu
  plotArr[[i]] <- PlotRsmOperatingCharacteristics(
    c(mu,mu),
    c(lambda,lambda),
    c(nu,nu),
    c(zetaOptArr[1,i], zetaOptArr[2,i]),
    lesDistr,
    relWeights,
    OpChType = "wAFROC",
    legendPosition = "null"
  )$wAFROCPlot +
    ggtitle(paste0("mu = ", mu, ", nu = ", nuP, ", lambda = ", lambdaPArr[i]))
}
```



Fig. \@ref(fig:optim-op-point-vary-lambda-wafroc) shows wAFROC plots for the two optimization methods. Each plot consists of a continuous line followed by a dashed line. The "green-red-red-dashed curve" ^[Since the two plots overlap in the initial steep portion of the plots it is necessary to adopt a perhaps unconventional color coding convention in describing each plot: the green-red-red-dashed curve starts off as the continuous green line - which overlaps a red line - followed by the continuous red line and completed by the dashed red line.] corresponds to wAFROC-AUC optimization and the green-green-dashed curve corresponds to Youden-index optimization. 

The transition from continuous to dashed is determined by the value of $\zeta_1$. It occurs at a higher value of $\zeta_1$ for the Youden-index optimization, Table \@ref(tab:optim-op-point-table-vary-lambda). The stricter reporting threshold sacrifices some of the area under the wAFROC resulting in lower performance, particularly for the lower values of $\lambda$. At the highest value of $\lambda$ the values of optimal $\zeta_1$ are similar and both methods make similar predictions: the corresponding wAFROC-AUCs are `r simplePrint(wAfrocArr[1,4])` and  `r simplePrint(wAfrocArr[2,4])`.



```{r optim-op-point-vary-lambda-wafroc, fig.cap="wAFROC plots for the two optimization methods: the green-red-red-dashed curve corresponds to wAFROC-AUC optimization and the green-green curve corresponds to Youden-index optimization.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]],plotArr[[2]],plotArr[[3]],plotArr[[4]], nrow = 2, ncol = 2)
```


The continuous section of each curve ends at the optimal threshold listed in Table \@ref(tab:optim-op-point-table-vary-lambda), namely $\zeta_1$ = `r simplePrint(zetaOptArr[1,1])` for the green-red-red-dashed curve and $\zeta_1$ = `r simplePrint(zetaOptArr[2,1])` for the green curve. The lower performance represented by the green curve, based on Youden-index maximization, is due to the adoption of an overly strict threshold.




### Illustrative ROC plots

To confirm true performance one compares ROC curves.    



```{r, attr.source = ".numberLines", echo=FALSE}
plotArr <- array(list(), dim = 4)
for (i in 1:4) {
  x <- UtilPhysical2IntrinsicRSM(mu, lambdaP = lambdaPArr[i], nuP = nuP)
  lambda <- x$lambda
  nu <- x$nu
  plotArr[[i]] <- PlotRsmOperatingCharacteristics(
    c(mu,mu),
    c(lambda,lambda),
    c(nu,nu),
    c(zetaOptArr[1,i], zetaOptArr[2,i]),
    lesDistr,
    relWeights,
    OpChType = "ROC",
    legendPosition = "null"
  )$ROCPlot +
    ggtitle(paste0("mu = ", mu, ", nu = ", nuP, ", lambda = ", lambdaPArr[i]))
}
```




TBA ROC curves for wAFROC-AUC and Youden-index based optimizations: both curves correspond to $\mu = 2$, $\nu = 1$ and $\lambda = 1$. The optimal reporting theshold $\zeta_1$ is determined by the selected FOM. The green-red-red-dashed curve corresponds to FOM = wAFROC-AUC and the green curve corresponds to FOM = Youden-index. The stricter reporting threshold found by the Youden-index based method sacrifices a considerable amount of area under the ROC.  The two ROC-AUCs are 0.929 and 0.899, respectively.



```{r optim-op-point-vary-lambda-roc, fig.cap="ROC plots for the two optimization methods: the green-red-red-dashed curve corresponds to wAFROC-AUC optimization and the green-green curve corresponds to Youden-index optimization.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]],plotArr[[2]],plotArr[[3]],plotArr[[4]], nrow = 2, ncol = 2)
```


The continuous section of each curve ends at the optimal threshold listed in Table \@ref(tab:optim-op-point-table-vary-lambda). The lower performance represented by the green curve, based on Youden-index maximization, is due to the adoption of an overly strict threshold.






## Appendix 1: Optimizations involving varying $\nu$  {#optim-op-point-vary-nu}

For $\mu = 2$ and $\lambda = 1$ optimizations were performed for $\nu = 0.6, 0.7, 0.8, 0.9$. 


Table \@ref(tab:optim-op-point-table-vary-nu) summarizes these results. The column labeled FOM shows the quantity being maximized, $\nu$ corresponds to the 4 values of $\nu$, $\zeta_1$ is the optimal value of $\zeta_1$ that maximizes the chosen figure of merit. All quantities in columns 3 through 6 are functions of $x\mu \lambda \nu$, where x = 1 for wAFROC and x = 2 for Youden-index. The column labeled wAFROC is the AUC under the wAFROC curve, the column labeled ROC is the AUC under the ROC curve, and $\left( \text{NLF}, \text{LLF}\right)$ is the optimal operating point on the FROC curve. 



```{r optim-op-point-computations-nu, cache = FALSE, echo=FALSE, attr.source = ".numberLines"}
mu <- 2
lambdaP <- 1
nuPArr <- c(0.6, 0.7, 0.8, 0.9)
wAfrocArr <- array(dim = c(2,length(nuPArr)))
zetaOptArr <- array(dim = c(2,length(nuPArr)))
rocArr <- array(dim = c(2,length(nuPArr)))
nlfOptArr <- array(dim = c(2,length(nuPArr)))
llfOptArr <- array(dim = c(2,length(nuPArr)))
lesDistr <- c(0.5, 0.5)
relWeights <- c(0.5, 0.5)
for (y in 1:2) {
  for (i in 1:length(nuPArr)) {
    nuP <- nuPArr[i]
    if (y == 1) {
      x <- optimize(wAFROC, 
                    interval = c(-5,5), 
                    mu, 
                    lambdaP = lambdaP, 
                    nuP = nuP, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      wAfrocArr[y,i] <- -x$objective # safe to use objective here
      rocArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambdaP = lambdaP, 
        nuP = nuP, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        lambdaP = lambdaP)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, 
        mu, 
        nuP = nuP)
    } else if (y == 2) {
      x <- optimize(Youden, 
                    interval = c(-5,5), 
                    mu, 
                    lambdaP = lambdaP, 
                    nuP = nuP, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      wAfrocArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambdaP = lambdaP, 
        nuP = nuP, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucwAFROC
      rocArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambdaP = lambdaP, 
        nuP = nuP, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        lambdaP = lambdaP)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, mu, nuP)
    } else stop("incorrect y")
  }
}
```





```{r optim-op-point-table-vary-nu-contents, echo=FALSE}
x1 <- cbind(rep("wAFROC",4), nu = nuPArr, zeta1 = simplePrint(zetaOptArr[1,]), wAFROC = simplePrint(wAfrocArr[1,]), ROC = simplePrint(rocArr[1,]), OptOpPt = OpPtStr(nlfOptArr[1,], llfOptArr[1,]))
x2 <- cbind(rep("Youden",4), nu = nuPArr, zeta1 = simplePrint(zetaOptArr[2,]), wAFROC = simplePrint(wAfrocArr[2,]), ROC = simplePrint(rocArr[2,]), OptOpPt = OpPtStr(nlfOptArr[2,], llfOptArr[2,]))
x12 <- as.data.frame(rbind(x1,x2))
colnames(x12) <- c("FOM", "$\\nu$", "$\\zeta_1$", "$\\text{wAFROC}$", "$\\text{ROC}$", "$\\left( \\text{NLF}, \\text{LLF}\\right)$")
```



```{r optim-op-point-table-vary-nu, echo=FALSE}
kbl(x12, caption = "Summary of optimization results for $\\mu = 2$, $\\lambda = 1$ and 4 values of $\\nu$.", booktabs = TRUE, escape = FALSE) %>% collapse_rows(columns = c(1), valign = "middle") %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```


The $\lambda$ parameter controls the average number of perceived NLs per case. For $\lambda = 1$ there is, on average, one perceived NL for every non-diseased case and the optimal wAFROC-based threshold is $\zeta_{1;1,\mu, \lambda = 1, \nu}$ = `r simplePrint(zetaOptArr[1,1])`. For $\lambda = 10$ there are ten perceived NLs for every non-diseased case and the optimal wAFROC-based threshold is $\zeta_{1;1,\mu, \lambda = 10, \nu}$ = `r simplePrint(zetaOptArr[1,4])`. The increase in $\zeta_1$ effect should be familiar to CAD/AI algorithm designers: with increasing numbers of NLs per case it is necessary to increase the reporting threshold (i.e., adopt a stricter reporting criteria). Also, overall CAD/AI performance decreases, regardless of how it is measured (i.e., wAFROC-AUC or ROC-AUC) and the optimal operating point on the FROC, $\left( \text{NLF}, \text{LLF}\right)$, moves down the curve.   


With larger $\lambda$ overall optimized performance is expected to be lower as confirmed by the corresponding wAFROC-AUC and ROC-AUC values. This is due to two reinforcing effects: performance goes down with increasing numbers of NLs per case and performance goes down with increasing reporting threshold. 

While these effects are also true for the Youden-index based optimizations, the optimal thresholds are collectively higher than the corresponding wAFROC based optimizations, especially for the lower values of $\lambda$: $\zeta_{1;2,\mu, \lambda = 1, \nu}$ = `r simplePrint(zetaOptArr[2,1])` and $\zeta_{1;2,\mu, \lambda = 10, \nu}$ = `r simplePrint(zetaOptArr[2,4])`. This results in lower wAFROC-AUC and ROC-AUC values when using Youden-index based optimizations.

The ROC-AUCs are reported as a check of the less familar wAFROC-AUC figure of merit. It is evident that the ordering of the two optimization methods is independent of whether it is measured via the wAFROC-AUC or the ROC-AUC: either way the wAFROC-AUC based optimizations yield higher AUC values and higher operating points on the FROC than the corresponding Youden-index based optimizations.   


### Illustrative FROC plots

TBA



```{r, attr.source = ".numberLines", echo=FALSE}
plotArr <- array(list(), dim = 4)
for (i in 1:4) {
  z <- seq(-5,mu+5,0.1)
  nuP <- nuPArr[i]
  xFROC <- RSM_xFROC(z, lambdaP)
  yFROC <- RSM_yFROC(z, mu, nuP)
  df_froc <- data.frame(
    NLF = xFROC, 
    LLF = yFROC)
  plotArr[[i]] <- ggplot2::ggplot(
    df_froc, 
    aes(x = NLF, y = LLF)) + 
    geom_line() +
    scale_x_continuous(limits = c(0,lambdaP)) + 
    scale_y_continuous(limits = c(0,1)) +
    ggtitle(paste0("mu = ", mu, ", nu = ", nuPArr[i], ", lambda = ", lambdaP))
  for (y in 1:2) {
    optPt <- data.frame(
      NLF = nlfOptArr[y,i], 
      LLF = llfOptArr[y,i])
    plotArr[[i]] <- plotArr[[i]] + 
      geom_point(data = optPt, color = y) 
  }
}
```




```{r optim-op-point-vary-nu-froc, fig.cap = "FROC plots with superimposed operating points for varying $\\nu$. The black dot is when maximized wAFROC AUC was used to find the optimal operating point and red dot is when maximized Youden-index was used.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
```



TBA These plots illustrate the previous comments, namely, as $\lambda$ increases, the optimal operating point moves *down* the scaled curve corresponding to adoption of progressively more stringent reporting thresholds.



### Illustrative wAFROC plots

To visualize true performance one compares wAFROC curves.    



```{r, attr.source = ".numberLines", echo=FALSE}
plotArr <- array(list(), dim = 4)
for (i in 1:4) {
  x <- UtilPhysical2IntrinsicRSM(mu, lambdaP = lambdaP, nuP = nuPArr[i])
  lambda <- x$lambda
  nu <- x$nu
  plotArr[[i]] <- PlotRsmOperatingCharacteristics(
    c(mu,mu),
    c(lambda,lambda),
    c(nu,nu),
    c(zetaOptArr[1,i], zetaOptArr[2,i]),
    lesDistr,
    relWeights,
    OpChType = "wAFROC",
    legendPosition = "null"
  )$wAFROCPlot +
    ggtitle(paste0("mu = ", mu, ", nu = ", nuPArr[i], ", lambda = ", lambdaP))
}
```



TBA wAFROC curves for wAFROC-AUC and Youden-index based optimizations: both curves correspond to $\mu = 2$, $\nu = 1$ and $\lambda = 1$. The optimal reporting theshold $\zeta_1$ is determined by the selected FOM. The green-red-red-dashed curve corresponds to FOM = wAFROC-AUC and the green curve corresponds to FOM = Youden-index. The stricter reporting threshold found by the Youden-index based method sacrifices a considerable amount of area under the wAFROC.  The two wAFROC-AUCs are 0.880 and 0.856, respectively.



```{r optim-op-point-vary-nu-wafroc, fig.cap="wAFROC plots for the two optimization methods: the green-red-red-dashed curve corresponds to wAFROC-AUC optimization and the green-green curve corresponds to Youden-index optimization.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
```


The continuous section of each curve ends at the optimal threshold listed in Table \@ref(tab:optim-op-point-table-vary-nu), namely $\zeta_1$ = `r simplePrint(zetaOptArr[1,1])` for the green-red-red-dashed curve and $\zeta_1$ = `r simplePrint(zetaOptArr[2,1])` for the green curve. The lower performance represented by the green curve, based on Youden-index maximization, is due to the adoption of an overly strict threshold.




### Illustrative ROC plots

To confirm true performance one compares ROC curves.    



```{r, attr.source = ".numberLines", echo=FALSE}
plotArr <- array(list(), dim = 4)
for (i in 1:4) {
  x <- UtilPhysical2IntrinsicRSM(mu, lambdaP = lambdaP, nuP = nuPArr[i])
  lambda <- x$lambda
  nu <- x$nu
  plotArr[[i]] <- PlotRsmOperatingCharacteristics(
    c(mu,mu),
    c(lambda,lambda),
    c(nu,nu),
    c(zetaOptArr[1,i], zetaOptArr[2,i]),
    lesDistr,
    relWeights,
    OpChType = "ROC",
    legendPosition = "null"
  )$ROCPlot +
    ggtitle(paste0("mu = ", mu, ", nu = ", nuPArr[i], ", lambda = ", lambdaP))
}
```



TBA ROC curves for wAFROC-AUC and Youden-index based optimizations: both curves correspond to $\mu = 2$, $\nu = 1$ and $\lambda = 1$. TBA The optimal reporting theshold $\zeta_1$ is determined by the selected FOM. The green-red-red-dashed curve corresponds to FOM = wAFROC-AUC and the green curve corresponds to FOM = Youden-index. The stricter reporting threshold found by the Youden-index based method sacrifices a considerable amount of area under the ROC.  The two ROC-AUCs are 0.929 and 0.899, respectively.




```{r optim-op-point-vary-nu-roc, fig.cap="ROC plots for the two optimization methods: the green-red-red-dashed curve corresponds to wAFROC-AUC optimization and the green-green curve corresponds to Youden-index optimization.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
```


The continuous section of each curve ends at the optimal threshold listed in Table \@ref(tab:optim-op-point-table-vary-nu). The lower performance represented by the green curve, based on Youden-index maximization, is due to the adoption of an overly strict threshold.






## Appendix 2: Optimizations involving varying $\mu$  {#optim-op-point-vary-mu}

For $\lambda = 1$ and $\nu = 0.9$ optimizations were performed for $\mu = 1, 2, 3, 4$. 


Table \@ref(tab:optim-op-point-table-vary-mu) summarizes these results. The column labeled FOM shows the quantity being maximized, $\nu$ corresponds to the 4 values of $\nu$, $\zeta_1$ is the optimal value of $\zeta_1$ that maximizes the chosen figure of merit. All quantities in columns 3 through 6 are functions of $x\mu \lambda \nu$, where x = 1 for wAFROC and x = 2 for Youden-index. The column labeled wAFROC is the AUC under the wAFROC curve, the column labeled ROC is the AUC under the ROC curve, and $\left( \text{NLF}, \text{LLF}\right)$ is the optimal operating point on the FROC curve. 



```{r optim-op-point-computations-mu, cache = FALSE, echo=FALSE, attr.source = ".numberLines"}
lambdaP <- 1
nuP <- 0.9
muArr <- c(1, 2, 3, 4)
wAfrocArr <- array(dim = c(2,length(muArr)))
zetaOptArr <- array(dim = c(2,length(muArr)))
rocArr <- array(dim = c(2,length(muArr)))
nlfOptArr <- array(dim = c(2,length(muArr)))
llfOptArr <- array(dim = c(2,length(muArr)))
lesDistr <- c(0.5, 0.5)
relWeights <- c(0.5, 0.5)
for (y in 1:2) {
  for (i in 1:length(muArr)) {
    mu <- muArr[i]
    if (y == 1) {
      x <- optimize(wAFROC, 
                    interval = c(-5,5), 
                    mu, 
                    lambdaP = lambdaP, 
                    nuP = nuP, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      wAfrocArr[y,i] <- -x$objective # safe to use objective here
      rocArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambdaP = lambdaP, 
        nuP = nuP, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        lambdaP = lambdaP)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, 
        mu, 
        nuP = nuP)
    } else if (y == 2) {
      x <- optimize(Youden, 
                    interval = c(-5,5), 
                    mu, 
                    lambdaP = lambdaP, 
                    nuP = nuP, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      wAfrocArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambdaP = lambdaP, 
        nuP = nuP, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucwAFROC
      rocArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambdaP = lambdaP, 
        nuP = nuP, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        lambdaP = lambdaP)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, mu, nuP)
    } else stop("incorrect y")
  }
}
```





```{r optim-op-point-table-vary-mu-contents, echo=FALSE}
x1 <- cbind(rep("wAFROC",4), mu = muArr, zeta1 = simplePrint(zetaOptArr[1,]), wAFROC = simplePrint(wAfrocArr[1,]), ROC = simplePrint(rocArr[1,]), OptOpPt = OpPtStr(nlfOptArr[1,], llfOptArr[1,]))
x2 <- cbind(rep("Youden",4), mu = muArr, zeta1 = simplePrint(zetaOptArr[2,]), wAFROC = simplePrint(wAfrocArr[2,]), ROC = simplePrint(rocArr[2,]), OptOpPt = OpPtStr(nlfOptArr[2,], llfOptArr[2,]))
x12 <- as.data.frame(rbind(x1,x2))
colnames(x12) <- c("FOM", "$\\mu$", "$\\zeta_1$", "$\\text{wAFROC}$", "$\\text{ROC}$", "$\\left( \\text{NLF}, \\text{LLF}\\right)$")
```



```{r optim-op-point-table-vary-mu, echo=FALSE}
kbl(x12, caption = "Summary of optimization results for $\\lambda = 1$, $\\nu = 0.9$  and 4 values of $\\mu$.", booktabs = TRUE, escape = FALSE) %>% collapse_rows(columns = c(1), valign = "middle") %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```


The $\lambda$ parameter controls the average number of perceived NLs per case. For $\lambda = 1$ there is, on average, one perceived NL for every non-diseased case and the optimal wAFROC-based threshold is $\zeta_{1;1,\mu, \lambda = 1, \nu}$ = `r simplePrint(zetaOptArr[1,1])`. For $\lambda = 10$ there are ten perceived NLs for every non-diseased case and the optimal wAFROC-based threshold is $\zeta_{1;1,\mu, \lambda = 10, \nu}$ = `r simplePrint(zetaOptArr[1,4])`. The increase in $\zeta_1$ effect should be familiar to CAD/AI algorithm designers: with increasing numbers of NLs per case it is necessary to increase the reporting threshold (i.e., adopt a stricter reporting criteria). Also, overall CAD/AI performance decreases, regardless of how it is measured (i.e., wAFROC-AUC or ROC-AUC) and the optimal operating point on the FROC, $\left( \text{NLF}, \text{LLF}\right)$, moves down the curve.   


With larger $\lambda$ overall optimized performance is expected to be lower as confirmed by the corresponding wAFROC-AUC and ROC-AUC values. This is due to two reinforcing effects: performance goes down with increasing numbers of NLs per case and performance goes down with increasing reporting threshold. 

While these effects are also true for the Youden-index based optimizations, the optimal thresholds are collectively higher than the corresponding wAFROC based optimizations, especially for the lower values of $\lambda$: $\zeta_{1;2,\mu, \lambda = 1, \nu}$ = `r simplePrint(zetaOptArr[2,1])` and $\zeta_{1;2,\mu, \lambda = 10, \nu}$ = `r simplePrint(zetaOptArr[2,4])`. This results in lower wAFROC-AUC and ROC-AUC values when using Youden-index based optimizations.

The ROC-AUCs are reported as a check of the less familar wAFROC-AUC figure of merit. It is evident that the ordering of the two optimization methods is independent of whether it is measured via the wAFROC-AUC or the ROC-AUC: either way the wAFROC-AUC based optimizations yield higher AUC values and higher operating points on the FROC than the corresponding Youden-index based optimizations.   


### Illustrative FROC plots

TBA


```{r, attr.source = ".numberLines", echo=FALSE}
plotArr <- array(list(), dim = 4)
for (i in 1:4) {
  z <- seq(-5,muArr[i]+5,0.1)
  mu <- muArr[i]
  xFROC <- RSM_xFROC(z, lambdaP)
  yFROC <- RSM_yFROC(z, mu, nuP)
  df_froc <- data.frame(
    NLF = xFROC, 
    LLF = yFROC)
  plotArr[[i]] <- ggplot2::ggplot(
    df_froc, 
    aes(x = NLF, y = LLF)) + 
    geom_line() +
    scale_x_continuous(limits = c(0,lambdaP)) + 
    scale_y_continuous(limits = c(0,1)) +
    ggtitle(paste0("mu = ", muArr[i], ", nu = ", nuP, ", lambda = ", lambdaP))
  for (y in 1:2) {
    optPt <- data.frame(
      NLF = nlfOptArr[y,i], 
      LLF = llfOptArr[y,i])
    plotArr[[i]] <- plotArr[[i]] + 
      geom_point(data = optPt, color = y)
  }
}
```




```{r optim-op-point-vary-mu-froc, fig.cap = "FROC plots with superimposed operating points for varying $\\mu$. The black dot is when maximized wAFROC AUC was used to find the optimal operating point and red dot is when maximized Youden-index was used.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
```


TBA These plots illustrate the previous comments, namely, as $\lambda$ increases, the optimal operating point moves *down* the scaled curve corresponding to adoption of progressively more stringent reporting thresholds.



### Illustrative wAFROC plots

To visualize true performance one compares wAFROC curves.    



```{r, attr.source = ".numberLines", echo=FALSE}
plotArr <- array(list(), dim = 4)
for (i in 1:4) {
  mu <- muArr[i]
  x <- UtilPhysical2IntrinsicRSM(mu, lambdaP = lambdaP, nuP = nuP)
  lambda <- x$lambda
  nu <- x$nu
  plotArr[[i]] <- PlotRsmOperatingCharacteristics(
    c(mu,mu),
    c(lambda,lambda),
    c(nu,nu),
    c(zetaOptArr[1,i], zetaOptArr[2,i]),
    lesDistr,
    relWeights,
    OpChType = "wAFROC",
    legendPosition = "null"
  )$wAFROCPlot +
    ggtitle(paste0("mu = ", muArr[i], ", nu = ", nuP, ", lambda = ", lambdaP))
}
```




TBA wAFROC curves for wAFROC-AUC and Youden-index based optimizations: both curves correspond to $\mu = 2$, $\nu = 1$ and $\lambda = 1$. The optimal reporting theshold $\zeta_1$ is determined by the selected FOM. The green-red-red-dashed curve corresponds to FOM = wAFROC-AUC and the green curve corresponds to FOM = Youden-index. The stricter reporting threshold found by the Youden-index based method sacrifices a considerable amount of area under the wAFROC.  The two wAFROC-AUCs are 0.880 and 0.856, respectively.



```{r optim-op-point-vary-mu-wafroc, fig.cap="wAFROC plots for the two optimization methods: the green-red-red-dashed curve corresponds to wAFROC-AUC optimization and the green-green curve corresponds to Youden-index optimization.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
```


The continuous section of each curve ends at the optimal threshold listed in Table \@ref(tab:optim-op-point-table-vary-mu), namely $\zeta_1$ = `r simplePrint(zetaOptArr[1,1])` for the green-red-red-dashed curve and $\zeta_1$ = `r simplePrint(zetaOptArr[2,1])` for the green curve. The lower performance represented by the green curve, based on Youden-index maximization, is due to the adoption of an overly strict threshold.




### Illustrative ROC plots

To confirm true performance one compares ROC curves.    



```{r, attr.source = ".numberLines", echo=FALSE}
plotArr <- array(list(), dim = 4)
for (i in 1:4) {
  mu <- muArr[i]
  x <- UtilPhysical2IntrinsicRSM(mu, lambdaP = lambdaP, nuP = nuP)
  lambda <- x$lambda
  nu <- x$nu
  plotArr[[i]] <- PlotRsmOperatingCharacteristics(
    c(mu,mu),
    c(lambda,lambda),
    c(nu,nu),
    c(zetaOptArr[1,i], zetaOptArr[2,i]),
    lesDistr,
    relWeights,
    OpChType = "ROC",
    legendPosition = "null"
  )$ROCPlot +
    ggtitle(paste0("mu = ", muArr[i], ", nu = ", nuP, ", lambda = ", lambdaP))
}
```



TBA ROC curves for wAFROC-AUC and Youden-index based optimizations: both curves correspond to $\mu = 2$, $\nu = 1$ and $\lambda = 1$. TBA The optimal reporting theshold $\zeta_1$ is determined by the selected FOM. The green-red-red-dashed curve corresponds to FOM = wAFROC-AUC and the green curve corresponds to FOM = Youden-index. The stricter reporting threshold found by the Youden-index based method sacrifices a considerable amount of area under the ROC.  The two ROC-AUCs are 0.929 and 0.899, respectively.




```{r optim-op-point-vary-mu-roc, fig.cap="ROC plots for the two optimization methods: the green-red-red-dashed curve corresponds to wAFROC-AUC optimization and the green-green curve corresponds to Youden-index optimization.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
```


The continuous section of each curve ends at the optimal threshold listed in Table \@ref(tab:optim-op-point-table-vary-mu). The lower performance represented by the green curve, based on Youden-index maximization, is due to the adoption of an overly strict threshold.






## References {#optim-op-point-references}
