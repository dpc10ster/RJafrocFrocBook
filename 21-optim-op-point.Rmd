# Optimal operating point on FROC {#optim-op-point}

---
output:
  rmarkdown::pdf_document:
    fig_caption: yes        
    includes:  
      in_header: R/learn/my_header.tex
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval.after = "fig.cap"
)

library(RJafroc)
library(ggplot2)
library(kableExtra)
library(gridExtra)
library(abind)
library(dplyr)
```



```{r, echo=FALSE}
OpPtStr <- function(x,y) {
  y <- paste0("(", sprintf("%.3f", x), ", ", sprintf("%.3f", y), ")")
  return(y)
}

simplePrint <- function(x) {
  sprintf("%.3f", x)
}
```



## TBA How much finished {#optim-op-point-how-much-finished}
80%

Discussion and Intro need more work; coding is done


## Introduction {#optim-op-point-intro}

This chapter deals with finding the optimal reporting threshold of an algorithmic observer, such as CAD/AI. We assume that designer level FROC data is available for the algorithm, i.e., the data consists of mark-rating pairs, with continuous-scale ratings, and a decision needs to be made as to the optimal reporting threshold, i.e., the minimum rating of a mark before it is shown to the radiologist. This is a familiar problem faced by a CAD/AI algorithm designer. 

The problem has been solved in the context of ROC analysis [@metz1978rocmethodology], namely, the optimal operating point on the ROC corresponds to a slope determined by disease prevalence and the cost of decisions in the four basic binary paradigm categories: true and false positives and true and false negatives. In practice the costs are difficult to quantify. However, for equal numbers of diseased and non-diseased cases and equal costs it can be shown that the slope of the ROC curve at the optimal point is unity. For a proper ROC curve this corresponds to the point that maximizes the Youden-index [@youden1950index], defined as the sum of sensitivity and specificity minus one. Typically it is maximized at the point that is closest to the (0,1) corner of the ROC. 

CAD/AI produces FROC data and lacking a procedure for setting it analytically, CAD/AI manufacturers, in consultation with radiologists, set site-specific reporting thresholds. For example, if radiologists at a site are comfortable with more false marks as the price of potentially greater lesion-level sensitivity, the reporting threshold for them is adjusted downward. 

This chapter describes an analytic method for finding the optimal reporting threshold. The method is based on maximizing AUC (area under curve) under the wAFROC curve. The method is compared to the Youden-index based method.   



## Methods {#optim-op-point-methods}

Terminology: 
Non-lesion localizations = NLs, i.e., location level "false positives".
Lesion localizations = LLs, i.e., location level "true positives".
Latent marks = perceived suspicious regions that are not necessarily marked.

Background on the radiological search model (RSM) is provided in Chapter \@ref(rsm). The model predicts ROC, FROC and wAFROC curves. These curves are completely defined by the RSM parameters -- $\lambda$, $\nu$, $\mu$ and $\zeta_1$ -- which have the following meanings:

* The $\mu$ parameter, $\mu \ge 0$, is the perceptual signal to noise ratio of lesions. Higher values of $\mu$ lead to increased separation of two unit variance normal distributions determining the ratings of perceived NLs and LL. As $\mu$ increases performance of the algorithm increases.

* The $\lambda$ parameter, $\lambda \ge 0$, determines the mean number of latent NLs per case. Higher values lead to more latent NL marks per case and decreased performance. 

* The $\nu$ parameter, $0 \le \nu \le 1$, determines the probability of latent LLs, i.e., the probability that any present lesion will be perceived. Higher values of $\nu$ lead to more latent LL marks and increased performance.  

* The $\zeta_1$ parameter determines if a suspicious region found by the algorithm is actually marked (if the z-sample exceeds $\zeta_1$ the latent mark becomes an actual mark). Higher values correspond to more stringent reporting criteria and fewer reported marks. Performance, as measured by wAFROC-AUC or the Youden-index, peaks at an optimal value of $\zeta_1$. The purpose of this chapter is to investigate this effect, i.e., given values of the other RSM parameters and the figure of merit to be optimized (i.e., wAFROC-AUC or the Youden-index), to determine the optimal value of $\zeta_1$.  


TBA (lay out rationale for following material) In the following sections each of the first three parameters is varied in turn and the corresponding optimal $\zeta_1$ determined by maximizing one of two figures of merit (FOMs), namely, the wAFROC-AUC and the Youden-index. The value maximizing wAFROC-AUC is denoted $\zeta_{1;1\mu \lambda \nu}$ and the value maximizing the Youden-index is denoted $\zeta_{2;\mu \lambda \nu}$. 


## Figures of merit to be maximized
The wAFROC figure of merit is implemented in the `RJafroc` function `UtilAnalyticalAucsRSM`. It was assumed that half of the diseased cases contain one lesion and the rest contain two lesions and the lesions are assigned equal weights (i.e., clinical importance).

The Youden-index is defined as the sum of sensitivity and specificity minus 1. Sensitivity is implemented in function `RSM_yROC` and specificity is `(1 - RSM_xROC)`. 


```{r foms_2be_maximized, echo=FALSE, attr.source = ".numberLines"}

wAFROC <- function (
  zeta1, mu, lambdaP, nuP, 
  lesDistr, 
  relWeights) {
  # return negative of aucwAFROC 
  # (as optimize finds minimum of function)
  return(-UtilAnalyticalAucsRSM(
    mu, 
    lambdaP = lambdaP, 
    nuP = nuP, 
    zeta1, 
    lesDistr, 
    relWeights)$aucwAFROC)
  
}


Youden <- function (
  zeta1, 
  mu, 
  lambdaP, 
  nuP, 
  lesDistr, 
  relWeights) {
  # add sensitivity and specificity 
  # and subtract 1, i.e., Youden's index
  x <- RSM_yROC(
    zeta1, 
    mu, 
    lambdaP, 
    nuP, 
    lesDistr) + 
    (1 - RSM_xROC(zeta1, lambdaP)) - 1
  # return negative of Youden-index 
  # (as optimize finds minimum of function)
  return(-x)
  
}
```


## Optimizations involving varying $\lambda$  {#optim-op-point-vary-lambda}

For $\mu = 2$ and $\nu = 1$ optimizations were performed for $\lambda = 1, 2, 5, 10$. The following quantities were calculated:

* $\zeta_{1;1\mu \lambda \nu}$, the optimal thresholds for wAFROC based optimizations and $\zeta_{1;2\mu \lambda \nu}$ for Youden-index based optimizations;
* $\text{wAFROC} \left (1\mu \lambda \nu \right )$, the optimal value of the wAFROC-AUC for wAFROC based optimizations; 
* $\text{wAFROC} \left (2\mu \lambda \nu \right )$, the optimal value of the wAFROC-AUC for Youden-index based optimizations. For consistency we always report wAFROC-AUC even when the optimized quantity is the Youden-index;
* $\text{ROC} \left (1\mu \lambda \nu \right )$, the AUCs under the ROC curves for wAFROC based optimizations;   
* $\text{ROC} \left (2\mu \lambda \nu \right )$, the AUCs under the ROC curves for Youden-index based optimizations;   
* $\text{\text{NLF}} \left (1\mu \lambda \nu \right )$ and $\text{\text{LLF}} \left (1\mu \lambda \nu \right )$: the coordinates of the optimal operating points on the FROC curve for wAFROC based optimizations;   
* $\text{\text{NLF}} \left (2\mu \lambda \nu \right )$ and $\text{\text{LLF}} \left (2\mu \lambda \nu \right )$: the coordinates of the optimal operating points on the FROC curve for Youden-index based optimizations.   


Table \@ref(tab:optim-op-point-table1) summarizes these results. The column labeled FOM shows the quantity being maximized, $\lambda$ corresponds to the 4 values of $\lambda$, $\zeta_1$ is the optimal value of $\zeta_1$ that maximizes the chosen figure of merit. All quantities in columns 3 through 6 are functions of $x\mu \lambda \nu$, where x = 1 for wAFROC and x = 2 for Youden-index. The column labeled wAFROC is the AUC under the wAFROC curve, the column labeled ROC is the AUC under the ROC curve, and $\left( \text{NLF}, \text{LLF}\right)$ is the optimal operating point on the FROC curve. 



```{r optim-op-point-computations-lambda, cache = FALSE, echo=FALSE, attr.source = ".numberLines"}
mu <- 2
nuP <- 0.9
lambdaPArr <- c(1, 2, 5,10)
wAfrocArr <- array(dim = c(2,length(lambdaPArr)))
zetaOptArr <- array(dim = c(2,length(lambdaPArr)))
rocArr <- array(dim = c(2,length(lambdaPArr)))
nlfOptArr <- array(dim = c(2,length(lambdaPArr)))
llfOptArr <- array(dim = c(2,length(lambdaPArr)))
lesDistr <- c(0.5, 0.5)
relWeights <- c(0.5, 0.5)
for (y in 1:2) {
  for (i in 1:length(lambdaPArr)) {
    lambdaP <- lambdaPArr[i]
    if (y == 1) {
      x <- optimize(wAFROC, 
                    interval = c(-5,5), 
                    mu, 
                    lambdaP = lambdaP, 
                    nuP = nuP, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      wAfrocArr[y,i] <- -x$objective # safe to use objective here
      rocArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambdaP = lambdaP, 
        nuP = nuP, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        lambdaP = lambdaP)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, 
        mu, 
        nuP = nuP)
    } else if (y == 2) {
      x <- optimize(Youden, 
                    interval = c(-5,5), 
                    mu, 
                    lambdaP, 
                    nuP, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      wAfrocArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambdaP = lambdaP, 
        nuP = nuP, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucwAFROC
      rocArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambdaP = lambdaP, 
        nuP = nuP, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        lambdaP = lambdaP)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, mu, nuP)
    } else stop("incorrect y")
  }
}
```





```{r optim-op-point-table1-contents, echo=FALSE}
x1 <- cbind(rep("wAFROC",4), lambda = lambdaPArr, zeta1 = simplePrint(zetaOptArr[1,]), wAFROC = simplePrint(wAfrocArr[1,]), ROC = simplePrint(rocArr[1,]), OptOpPt = OpPtStr(nlfOptArr[1,], llfOptArr[1,]))
x2 <- cbind(rep("Youden",4), lambda = lambdaPArr, zeta1 = simplePrint(zetaOptArr[2,]), wAFROC = simplePrint(wAfrocArr[2,]), ROC = simplePrint(rocArr[2,]), OptOpPt = OpPtStr(nlfOptArr[2,], llfOptArr[2,]))
x12 <- as.data.frame(rbind(x1,x2))
colnames(x12) <- c("FOM", "$\\lambda$", "$\\zeta_1$", "$\\text{wAFROC}$", "$\\text{ROC}$", "$\\left( \\text{NLF}, \\text{LLF}\\right)$")
```



```{r optim-op-point-table2, echo=FALSE}
kbl(x12, caption = "Summary of optimization results for $\\mu = 2$, $\\nu = 0.9$ and 4 values of $\\lambda$. All quantities in columns 3 through 6 are functions of $x\\mu \\lambda \\nu$, where x = 1 for wAFROC and x = 2 for Youden-index. The wAFROC column always displays wAFROC-AUC, even though the optimized quantity may the Youden-index, as in the last four rows.", booktabs = TRUE, escape = FALSE) %>% collapse_rows(columns = c(1), valign = "middle") %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```


The $\lambda$ parameter controls the average number of perceived NLs per case. For $\lambda = 1$ there is, on average, one perceived NL for every non-diseased case and the optimal wAFROC-based threshold is $\zeta_{1;1,\mu, \lambda = 1, \nu}$ = `r simplePrint(zetaOptArr[1,1])`. For $\lambda = 10$ there are ten perceived NLs for every non-diseased case and the optimal wAFROC-based threshold is $\zeta_{1;1,\mu, \lambda = 10, \nu}$ = `r simplePrint(zetaOptArr[1,4])`. The increase in $\zeta_1$ effect should be familiar to CAD/AI algorithm designers: with increasing numbers of NLs per case it is necessary to increase the reporting threshold (i.e., adopt a stricter reporting criteria). Also, overall CAD/AI performance decreases, regardless of how it is measured (i.e., wAFROC-AUC or ROC-AUC) and the optimal operating point on the FROC, $\left( \text{NLF}, \text{LLF}\right)$, moves down the curve.   


With larger $\lambda$ overall optimized performance is expected to be lower as confirmed by the corresponding wAFROC-AUC and ROC-AUC values. This is due to two reinforcing effects: performance goes down with increasing numbers of NLs per case and performance goes down with increasing reporting threshold. 

While these effects are also true for the Youden-index based optimizations, the optimal thresholds are collectively higher than the corresponding wAFROC based optimizations, especially for the lower values of $\lambda$: $\zeta_{1;2,\mu, \lambda = 1, \nu}$ = `r simplePrint(zetaOptArr[2,1])` and $\zeta_{1;2,\mu, \lambda = 10, \nu}$ = `r simplePrint(zetaOptArr[2,4])`. This results in lower wAFROC-AUC and ROC-AUC values when using Youden-index based optimizations.

The ROC-AUCs are reported as a check of the less familar wAFROC-AUC figure of merit. It is evident that the ordering of the two optimization methods is independent of whether it is measured via the wAFROC-AUC or the ROC-AUC: either way the wAFROC-AUC based optimizations yield higher AUC values and higher operating points on the FROC than the corresponding Youden-index based optimizations.   


### Illustrative FROC plots

One could display 8 FROC plots, each corresponding to a row of the preceding table, but there is a more efficient method. The FROC curve is defined in terms of the RSM parameters as follows:



\begin{equation}
\left. 
\begin{aligned}
\text{NLF} \left ( \zeta, \lambda \right ) =& \lambda \Phi \left (-\zeta \right ) \\
\text{LLF}\left ( \zeta, \mu, \nu \right ) =& \nu \Phi \left ( \mu - \zeta \right ) 
\end{aligned}
\right \}
(\#eq:rsm-froc-predictions)
\end{equation}


The *end-point* of the FROC defined by $\left ( \lambda, \nu \right )$ is not to be confused with the *optimal* value of $\zeta_1$; the former corresponds to $\zeta_1 = -\infty$ while the latter corresponds to the finite value of $\zeta_1$ as found by the optimization procedure.


Since the $\Phi$ function ranges from one to unity, the *four FROC curves for different values of $\lambda$ are scaled versions of a single curve whose x-axis ranges from 0 to 1*. The single curve corresponds to $\lambda = 1$ and the true curves are obtained by scaling this curve along the x-axis by the appropriate value of $\lambda$. With this understanding one can replace the 4 FROC curves with a single FROC curve where the scaled x-axis is $\text{NLF} \left ( \zeta, \lambda = 1 \right )$. The true FROC curve is then defined by:  



\begin{equation}
\left. 
\begin{aligned}
\text{NLF} \left ( \zeta, \lambda \right ) =& \lambda \text{NLF} \left ( \zeta, \lambda = 1 \right ) \\
\text{LLF}\left ( \zeta, \mu, \nu \right ) =& \nu \Phi \left ( \mu - \zeta \right ) 
\end{aligned}
\right \}
(\#eq:rsm-froc-predictions2)
\end{equation}




```{r, attr.source = ".numberLines", echo=FALSE}
scaled_froc <- array(list(), dim = 2)
for (y in 1:2) {
  i <- 1 # no need to generate scaled FROC 4 times
  z <- seq(-5,zetaOptArr[y,i]+5,0.1)
  lambdaP <- lambdaPArr[i]
  # scale x-axis to range (0,1) by dividing by lambdaP
  xFROC <- RSM_xFROC(z, lambdaP) / lambdaP
  yFROC <- RSM_yFROC(z, mu, nuP)
  df_scaled_froc <- data.frame(
    NLF_scaled = xFROC, 
    LLF = yFROC)
  scaled_froc[[y]] <- ggplot2::ggplot(
    df_scaled_froc, 
    aes(x = NLF_scaled, y = LLF)) + 
    geom_line() +
    scale_x_continuous(limits = c(0,1)) + 
    scale_y_continuous(limits = c(0,1))
  for ( i in 1:length(lambdaPArr)) {
    lambdaP <- lambdaPArr[i]
    # scale \text{NLF} value by dividing 
    # by lambdaP to match scaling of x-axis
    optPt <- data.frame(
      NLF_scaled = nlfOptArr[y,i] / lambdaP, 
      LLF = llfOptArr[y,i])
    scaled_froc[[y]] <- scaled_froc[[y]] + 
      geom_point(data = optPt, color = i)
  }
}
```




```{r optim-op-point-vary-lambda, fig.cap="Scaled FROC plots for varying $\\lambda$. Left panel: maximized wAFROC AUC was used to find optimal $\\zeta_1$. Right panel: maximized Youden-index was used to find optimal $\\zeta_1$. Dot colors: black is $\\lambda = 1$, red is $\\lambda = 2$, green is $\\lambda = 5$ and blue is $\\lambda = 10$.", fig.show='hold', echo=FALSE}
grid.arrange(scaled_froc[[1]], scaled_froc[[2]], ncol = 2)
```


The left panel in \@ref(fig:optim-op-point-vary-lambda) shows the optimal operating points when wAFROC-AUC is maximized. The 4 operating points are color coded as follows:

* The black dot corresponds to $\lambda = 1$. The true FROC is identical to that shown.  
* The red dot corresponds to $\lambda = 2$. The true FROC is obtained by *magnifying* that shown, including the red dot, along the x-axis by a factor of 2.   
* The green dot corresponds to $\lambda = 5$. The true FROC is obtained by *magnifying* along the x-axis by a factor of 5.  
* The blue dot corresponds to $\lambda = 10$. The true FROC is obtained by *magnifying* along the x-axis by a factor of 10.  

These plots illustrate the previous comments, namely, as $\lambda$ increases, the optimal operating point moves *down* the scaled curve corresponding to adoption of progressively more stringent reporting thresholds.

The right panel shows the optimal operating point when the Youden-index is maximized. It has the same general features as the previous example but, taken as a whole, the group of four operating points in the right panel are below-left those in the left panel, representing higher values of optimal $\zeta_1$, i.e., more stringent reporting criteria. As seen in Table \@ref(tab:optim-op-point-table1) the overly strict criteria resulting from using Youden-index based optimizations, lead to lower true performance: i.e., lower wAFROC-AUC and lower ROC-AUC. It also yields lower values of $\text{LLF}$, i.e., fewer correctly localized lesions.


### Illustrative wAFROC plots

To visualize true performance one compares wAFROC curves.    



```{r, attr.source = ".numberLines", echo=FALSE}
x <- UtilPhysical2IntrinsicRSM(mu, lambdaP = lambdaPArr[1], nuP = nuP)
lambda <- x$lambda
nu <- x$nu
wafroc <- PlotRsmOperatingCharacteristics(
     c(mu,mu),
     c(lambda,lambda),
     c(nu,nu),
     c(zetaOptArr[1,1], zetaOptArr[2,1]),
     lesDistr,
     relWeights,
     OpChType = "wAFROC",
     legendPosition = "null"
)$wAFROCPlot
```




```{r optim-op-point-vary-lambda-wafroc, fig.cap="wAFROC curves for wAFROC-AUC and Youden-index based optimizations: both curves correspond to $\\mu = 2$, $\\nu = 1$ and $\\lambda = 1$. The optimal reporting theshold $\\zeta_1$ is determined by the selected FOM. The green-red curve corresponds to FOM = wAFROC-AUC and the green curve corresponds to FOM = Youden-index. The stricter reporting threshold found by the Youden-index based method sacrifices a considerable amount of area under the wAFROC.  The two wAFROC-AUCs are 0.880 and 0.856, respectively.", fig.show='hold', echo=FALSE}
grid.arrange(wafroc)
```


The continuous section of each curve ends at the optimal threshold listed in Table \@ref(tab:optim-op-point-table1), namely $\zeta_1$ = `r simplePrint(zetaOptArr[1,1])` for the green-red curve and $\zeta_1$ = `r simplePrint(zetaOptArr[2,1])` for the green curve. The lower performance represented by the green curve, based on Youden-index maximization, is due to the adoption of an overly strict threshold.




### Illustrative ROC plots

To confirm true performance one compares ROC curves.    



```{r, attr.source = ".numberLines", echo=FALSE}
x <- UtilPhysical2IntrinsicRSM(mu, lambdaP = lambdaPArr[1], nuP = nuP)
lambda <- x$lambda
nu <- x$nu
roc <- PlotRsmOperatingCharacteristics(
     c(mu,mu),
     c(lambda,lambda),
     c(nu,nu),
     c(zetaOptArr[1,1], zetaOptArr[2,1]),
     lesDistr,
     relWeights,
     OpChType = "ROC",
     legendPosition = "null"
)$ROCPlot
```




```{r optim-op-point-vary-lambda-roc, fig.cap="ROC curves for wAFROC-AUC and Youden-index based optimizations: both curves correspond to $\\mu = 2$, $\\nu = 1$ and $\\lambda = 1$. The optimal reporting theshold $\\zeta_1$ is determined by the selected FOM. The green-red curve corresponds to FOM = wAFROC-AUC and the green curve corresponds to FOM = Youden-index. The stricter reporting threshold found by the Youden-index based method sacrifices a considerable amount of area under the ROC.  The two ROC-AUCs are 0.929 and 0.899, respectively.", fig.show='hold', echo=FALSE}
grid.arrange(roc)
```


The continuous section of each curve ends at the optimal threshold listed in Table \@ref(tab:optim-op-point-table1). The lower performance represented by the green curve, based on Youden-index maximization, is due to the adoption of an overly strict threshold.






## Appendix 1: Optimizations involving varying $\nu$  {#optim-op-point-vary-nu}

For $\mu = 2$ and $\lambda = 1$ optimizations were performed for $\nu = 0.6, 0.7, 0.8, 0.9$. The following quantities were calculated:

* $\zeta_{1;1\mu \lambda \nu}$, the optimal thresholds for wAFROC based optimizations and $\zeta_{1;2\mu \lambda \nu}$ for Youden-index based optimizations;
* $\text{wAFROC} \left (1\mu \lambda \nu \right )$, the optimal value of the wAFROC-AUC for wAFROC based optimizations; 
* $\text{wAFROC} \left (2\mu \lambda \nu \right )$, the optimal value of the wAFROC-AUC for Youden-index based optimizations. For consistency we always report wAFROC-AUC even when the optimized quantity is the Youden-index;
* $\text{ROC} \left (1\mu \lambda \nu \right )$, the AUCs under the ROC curves for wAFROC based optimizations;   
* $\text{ROC} \left (2\mu \lambda \nu \right )$, the AUCs under the ROC curves for Youden-index based optimizations;   
* $\text{\text{NLF}} \left (1\mu \lambda \nu \right )$ and $\text{\text{LLF}} \left (1\mu \lambda \nu \right )$: the coordinates of the optimal operating points on the FROC curve for wAFROC based optimizations;   
* $\text{\text{NLF}} \left (2\mu \lambda \nu \right )$ and $\text{\text{LLF}} \left (2\mu \lambda \nu \right )$: the coordinates of the optimal operating points on the FROC curve for Youden-index based optimizations.   


Table \@ref(tab:optim-op-point-table1) summarizes these results. The column labeled FOM shows the quantity being maximized, $\nu$ corresponds to the 4 values of $\nu$, $\zeta_1$ is the optimal value of $\zeta_1$ that maximizes the chosen figure of merit. All quantities in columns 3 through 6 are functions of $x\mu \lambda \nu$, where x = 1 for wAFROC and x = 2 for Youden-index. The column labeled wAFROC is the AUC under the wAFROC curve, the column labeled ROC is the AUC under the ROC curve, and $\left( \text{NLF}, \text{LLF}\right)$ is the optimal operating point on the FROC curve. 



```{r optim-op-point-computations-nu, cache = FALSE, echo=FALSE, attr.source = ".numberLines"}
mu <- 2
lambdaP <- 1
nuPArr <- c(0.6, 0.7, 0.8, 0.9)
wAfrocArr <- array(dim = c(2,length(nuPArr)))
zetaOptArr <- array(dim = c(2,length(nuPArr)))
rocArr <- array(dim = c(2,length(nuPArr)))
nlfOptArr <- array(dim = c(2,length(nuPArr)))
llfOptArr <- array(dim = c(2,length(nuPArr)))
lesDistr <- c(0.5, 0.5)
relWeights <- c(0.5, 0.5)
for (y in 1:2) {
  for (i in 1:length(nuPArr)) {
    nuP <- nuPArr[i]
    if (y == 1) {
      x <- optimize(wAFROC, 
                    interval = c(-5,5), 
                    mu, 
                    lambdaP = lambdaP, 
                    nuP = nuP, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      wAfrocArr[y,i] <- -x$objective # safe to use objective here
      rocArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambdaP = lambdaP, 
        nuP = nuP, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        lambdaP = lambdaP)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, 
        mu, 
        nuP = nuP)
    } else if (y == 2) {
      x <- optimize(Youden, 
                    interval = c(-5,5), 
                    mu, 
                    lambdaP, 
                    nuP, 
                    lesDistr, 
                    relWeights)
      zetaOptArr[y,i] <- x$minimum
      wAfrocArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambdaP = lambdaP, 
        nuP = nuP, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucwAFROC
      rocArr[y,i] <- UtilAnalyticalAucsRSM(
        mu, 
        lambdaP = lambdaP, 
        nuP = nuP, 
        zeta1 = x$minimum, 
        lesDistr, 
        relWeights)$aucROC
      nlfOptArr[y,i] <- RSM_xFROC(
        z = x$minimum, 
        lambdaP = lambdaP)
      llfOptArr[y,i] <- RSM_yFROC(
        z = x$minimum, mu, nuP)
    } else stop("incorrect y")
  }
}
```





```{r optim-op-point-table2-contents, echo=FALSE}
x1 <- cbind(rep("wAFROC",4), nu = nuPArr, zeta1 = simplePrint(zetaOptArr[1,]), wAFROC = simplePrint(wAfrocArr[1,]), ROC = simplePrint(rocArr[1,]), OptOpPt = OpPtStr(nlfOptArr[1,], llfOptArr[1,]))
x2 <- cbind(rep("Youden",4), nu = nuPArr, zeta1 = simplePrint(zetaOptArr[2,]), wAFROC = simplePrint(wAfrocArr[2,]), ROC = simplePrint(rocArr[2,]), OptOpPt = OpPtStr(nlfOptArr[2,], llfOptArr[2,]))
x12 <- as.data.frame(rbind(x1,x2))
colnames(x12) <- c("FOM", "$\\nu$", "$\\zeta_1$", "$\\text{wAFROC}$", "$\\text{ROC}$", "$\\left( \\text{NLF}, \\text{LLF}\\right)$")
```



```{r optim-op-point-table1, echo=FALSE}
kbl(x12, caption = "Summary of optimization results for $\\mu = 2$, $\\lambda = 1$ and 4 values of $\\nu$. All quantities in columns 3 through 6 are functions of $x\\mu \\lambda \\nu$, where x = 1 for wAFROC and x = 2 for Youden-index. The wAFROC column always displays wAFROC-AUC, even though the optimized quantity may the Youden-index, as in the last four rows.", booktabs = TRUE, escape = FALSE) %>% collapse_rows(columns = c(1), valign = "middle") %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```


The $\lambda$ parameter controls the average number of perceived NLs per case. For $\lambda = 1$ there is, on average, one perceived NL for every non-diseased case and the optimal wAFROC-based threshold is $\zeta_{1;1,\mu, \lambda = 1, \nu}$ = `r simplePrint(zetaOptArr[1,1])`. For $\lambda = 10$ there are ten perceived NLs for every non-diseased case and the optimal wAFROC-based threshold is $\zeta_{1;1,\mu, \lambda = 10, \nu}$ = `r simplePrint(zetaOptArr[1,4])`. The increase in $\zeta_1$ effect should be familiar to CAD/AI algorithm designers: with increasing numbers of NLs per case it is necessary to increase the reporting threshold (i.e., adopt a stricter reporting criteria). Also, overall CAD/AI performance decreases, regardless of how it is measured (i.e., wAFROC-AUC or ROC-AUC) and the optimal operating point on the FROC, $\left( \text{NLF}, \text{LLF}\right)$, moves down the curve.   


With larger $\lambda$ overall optimized performance is expected to be lower as confirmed by the corresponding wAFROC-AUC and ROC-AUC values. This is due to two reinforcing effects: performance goes down with increasing numbers of NLs per case and performance goes down with increasing reporting threshold. 

While these effects are also true for the Youden-index based optimizations, the optimal thresholds are collectively higher than the corresponding wAFROC based optimizations, especially for the lower values of $\lambda$: $\zeta_{1;2,\mu, \lambda = 1, \nu}$ = `r simplePrint(zetaOptArr[2,1])` and $\zeta_{1;2,\mu, \lambda = 10, \nu}$ = `r simplePrint(zetaOptArr[2,4])`. This results in lower wAFROC-AUC and ROC-AUC values when using Youden-index based optimizations.

The ROC-AUCs are reported as a check of the less familar wAFROC-AUC figure of merit. It is evident that the ordering of the two optimization methods is independent of whether it is measured via the wAFROC-AUC or the ROC-AUC: either way the wAFROC-AUC based optimizations yield higher AUC values and higher operating points on the FROC than the corresponding Youden-index based optimizations.   


### Illustrative FROC plots

One could display 8 FROC plots, each corresponding to a row of the preceding table, but there is a more efficient method. TBA But this time one scales along the y-axis. 



Since the $\Phi$ function ranges from one to unity, the *four FROC curves for different values of $\lambda$ are scaled versions of a single curve whose x-axis ranges from 0 to 1*. The single curve corresponds to $\lambda = 1$ and the true curves are obtained by scaling this curve along the x-axis by the appropriate value of $\lambda$. With this understanding one can replace the 4 FROC curves with a single FROC curve where the scaled x-axis is $\text{NLF} \left ( \zeta, \lambda = 1 \right )$. The true FROC curve is then defined by:  



\begin{equation}
\left. 
\begin{aligned}
\text{NLF} \left ( \zeta, \lambda \right ) =& \lambda \Phi \left ( -\zeta \right ) \\
\text{LLF}\left ( \zeta, \mu, \nu \right ) =& \nu \text{LLF} \left ( \zeta, \mu, \nu = 1 \right ) 
\end{aligned}
\right \}
(\#eq:rsm-froc-predictions3)
\end{equation}



```{r, attr.source = ".numberLines", echo=FALSE}
scaled_froc <- array(list(), dim = 2)
for (y in 1:2) {
  i <- 1 # no need to generate scaled FROC 4 times
  z <- seq(-5,zetaOptArr[y,i]+5,0.1)
  nuP <- nuPArr[i]
  xFROC <- RSM_xFROC(z, lambdaP) 
  # scale y-axis to range (0,1) by dividing by nuP
  yFROC <- RSM_yFROC(z, mu, nuP) / nuP
  df_scaled_froc <- data.frame(
    NLF = xFROC, 
    LLF_scaled = yFROC)
  scaled_froc[[y]] <- ggplot2::ggplot(
    df_scaled_froc, 
    aes(x = NLF, y = LLF_scaled)) + 
    geom_line() +
    scale_x_continuous(limits = c(0,1)) + 
    scale_y_continuous(limits = c(0,1))
  for ( i in 1:length(nuPArr)) {
    nuP <- nuPArr[i]
    # scale LLF value by dividing 
    # by nuP to match scaling of y-axis
    optPt <- data.frame(
      NLF = nlfOptArr[y,i], 
      LLF_scaled = llfOptArr[y,i] / nuP)
    scaled_froc[[y]] <- scaled_froc[[y]] + 
      geom_point(data = optPt, color = i)
  }
}
```




```{r optim-op-point-vary-nu, fig.cap="Scaled FROC plots for varying $\\nu$. Left panel: maximized wAFROC AUC was used to find optimal $\\zeta_1$. Right panel: maximized Youden-index was used to find optimal $\\zeta_1$. Dot colors: black is $\\nu = 0.6$, red is $\\nu = 0.7$, green is $\\nu = 0.8$ and blue is $\\nu = 0.9$.", fig.show='hold', echo=FALSE}
grid.arrange(scaled_froc[[1]], scaled_froc[[2]], ncol = 2)
```


The left panel in \@ref(fig:optim-op-point-vary-nu) shows the optimal operating points when wAFROC-AUC is maximized. The 4 operating points are color coded as follows:

* The black dot corresponds to $\lambda = 1$. The true FROC is identical to that shown.  
* The red dot corresponds to $\lambda = 2$. The true FROC is obtained by *magnifying* that shown, including the red dot, along the x-axis by a factor of 2.   
* The green dot corresponds to $\lambda = 5$. The true FROC is obtained by *magnifying* along the x-axis by a factor of 5.  
* The blue dot corresponds to $\lambda = 10$. The true FROC is obtained by *magnifying* along the x-axis by a factor of 10.  

These plots illustrate the previous comments, namely, as $\lambda$ increases, the optimal operating point moves *down* the scaled curve corresponding to adoption of progressively more stringent reporting thresholds.

The right panel shows the optimal operating point when the Youden-index is maximized. It has the same general features as the previous example but, taken as a whole, the group of four operating points in the right panel are below-left those in the left panel, representing higher values of optimal $\zeta_1$, i.e., more stringent reporting criteria. As seen in Table \@ref(tab:optim-op-point-table1) the overly strict criteria resulting from using Youden-index based optimizations, lead to lower true performance: i.e., lower wAFROC-AUC and lower ROC-AUC. It also yields lower values of $\text{LLF}$, i.e., fewer correctly localized lesions.


### Illustrative wAFROC plots

To visualize true performance one compares wAFROC curves.    



```{r, attr.source = ".numberLines", echo=FALSE}
x <- UtilPhysical2IntrinsicRSM(mu, lambdaP = lambdaP, nuP = nuPArr[4])
lambda <- x$lambda
nu <- x$nu
wafroc <- PlotRsmOperatingCharacteristics(
     c(mu,mu),
     c(lambda,lambda),
     c(nu,nu),
     c(zetaOptArr[1,1], zetaOptArr[2,1]),
     lesDistr,
     relWeights,
     OpChType = "wAFROC",
     legendPosition = "null"
)$wAFROCPlot
```




```{r optim-op-point-vary-nu-wafroc, fig.cap="wAFROC curves for wAFROC-AUC and Youden-index based optimizations: both curves correspond to $\\mu = 2$, $\\nu = 1$ and $\\lambda = 1$. The optimal reporting theshold $\\zeta_1$ is determined by the selected FOM. The green-red curve corresponds to FOM = wAFROC-AUC and the green curve corresponds to FOM = Youden-index. The stricter reporting threshold found by the Youden-index based method sacrifices a considerable amount of area under the wAFROC.  The two wAFROC-AUCs are 0.880 and 0.856, respectively.", fig.show='hold', echo=FALSE}
grid.arrange(wafroc)
```


The continuous section of each curve ends at the optimal threshold listed in Table \@ref(tab:optim-op-point-table1), namely $\zeta_1$ = `r simplePrint(zetaOptArr[1,1])` for the green-red curve and $\zeta_1$ = `r simplePrint(zetaOptArr[2,1])` for the green curve. The lower performance represented by the green curve, based on Youden-index maximization, is due to the adoption of an overly strict threshold.




### Illustrative ROC plots

To confirm true performance one compares ROC curves.    



```{r, attr.source = ".numberLines", echo=FALSE}
x <- UtilPhysical2IntrinsicRSM(mu, lambdaP = lambdaP, nuP = nuPArr[4])
lambda <- x$lambda
nu <- x$nu
roc <- PlotRsmOperatingCharacteristics(
     c(mu,mu),
     c(lambda,lambda),
     c(nu,nu),
     c(zetaOptArr[1,1], zetaOptArr[2,1]),
     lesDistr,
     relWeights,
     OpChType = "ROC",
     legendPosition = "null"
)$ROCPlot
```




```{r optim-op-point-vary-nu-roc, fig.cap="ROC curves for wAFROC-AUC and Youden-index based optimizations: both curves correspond to $\\mu = 2$, $\\nu = 1$ and $\\lambda = 1$. TBA The optimal reporting theshold $\\zeta_1$ is determined by the selected FOM. The green-red curve corresponds to FOM = wAFROC-AUC and the green curve corresponds to FOM = Youden-index. The stricter reporting threshold found by the Youden-index based method sacrifices a considerable amount of area under the ROC.  The two ROC-AUCs are 0.929 and 0.899, respectively.", fig.show='hold', echo=FALSE}
grid.arrange(roc)
```


The continuous section of each curve ends at the optimal threshold listed in Table \@ref(tab:optim-op-point-table1). The lower performance represented by the green curve, based on Youden-index maximization, is due to the adoption of an overly strict threshold.






## References {#optim-op-point-references}
