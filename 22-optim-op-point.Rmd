# Optimal operating point {#optim-op-point2}

---
output:
  rmarkdown::pdf_document:
    fig_caption: yes        
    includes:  
      in_header: R/learn/my_header.tex
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval.after = "fig.cap"
)

library(RJafroc)
library(ggplot2)
library(kableExtra)
library(gridExtra)
library(abind)
library(dplyr)
library(mvtnorm)
```



```{r, echo=FALSE}
OpPtStr <- function(x,y) {
  y <- paste0("(", sprintf("%.3f", x), ", ", sprintf("%.3f", y), ")")
  return(y)
}

simplePrint <- function(x) {
  sprintf("%.3f", x)
}
```




```{r foms_2be_maximized, echo=FALSE}

wAFROC <- function (
  zeta1, mu, lambdaP, nuP, 
  lesDistr, 
  relWeights) {
  # return negative of aucwAFROC 
  # (as optimize finds minimum of function)
  return(-UtilAnalyticalAucsRSM(mu, lambdaP = lambdaP, nuP = nuP, zeta1, lesDistr, relWeights)$aucwAFROC)
}


Youden <- function (zeta1, mu, lambdaP, nuP, lesDistr) {
  # add sensitivity and specificity 
  # and subtract 1, i.e., Youden's index
  x <- RSM_yROC(zeta1, mu, lambdaP, nuP, lesDistr) + 
    (1 - RSM_xROC(zeta1, lambdaP)) - 1
  # return negative of Youden-index 
  # (as optimize finds minimum of function)
  return(-x)
}
```




```{r do-one-set, cache = FALSE, echo=FALSE}
doOneSet <- function(muArr, lambdaPArr, nuPArr, lesDistr, relWeights) {
  wAfrocArr <- array(dim = c(2,length(muArr), length(lambdaPArr), length(nuPArr)))
  rocArr <- array(dim = c(2,length(muArr), length(lambdaPArr), length(nuPArr)))
  zetaOptArr <- array(dim = c(2,length(muArr), length(lambdaPArr), length(nuPArr)))
  fpfOptArr <- array(dim = c(2,length(muArr), length(lambdaPArr), length(nuPArr)))
  tpfOptArr <- array(dim = c(2,length(muArr), length(lambdaPArr), length(nuPArr)))
  nlfOptArr <- array(dim = c(2,length(muArr), length(lambdaPArr), length(nuPArr)))
  llfOptArr <- array(dim = c(2,length(muArr), length(lambdaPArr), length(nuPArr)))
  for (i1 in 1:length(muArr)) {
    for (i2 in 1:length(lambdaPArr)) {
      for (i3 in 1:length(nuPArr)) {
        mu <- muArr[i1]
        lambdaP <- lambdaPArr[i2]
        nuP <- nuPArr[i3]
        for (y in 1:2) {
          if (y == 1) {
            x <- optimize(wAFROC, 
                          interval = c(-5,5), 
                          mu, 
                          lambdaP = lambdaP, 
                          nuP = nuP, 
                          lesDistr, 
                          relWeights)
            zetaOptArr[y,i1,i2,i3] <- x$minimum
            wAfrocArr[y,i1,i2,i3] <- -x$objective # safe to use objective here
            rocArr[y,i1,i2,i3] <- UtilAnalyticalAucsRSM(
              mu, 
              lambdaP = lambdaP, 
              nuP = nuP, 
              zeta1 = x$minimum, 
              lesDistr, 
              relWeights)$aucROC
            fpfOptArr[y,i1,i2,i3] <- RSM_xROC(
              z = x$minimum, 
              lambdaP = lambdaP)
            tpfOptArr[y,i1,i2,i3] <- RSM_yROC(
              z = x$minimum, 
              mu, 
              lambdaP = lambdaP,
              nuP = nuP,
              lesDistr = lesDistr)
            nlfOptArr[y,i1,i2,i3] <- RSM_xFROC(
              z = x$minimum, 
              lambdaP = lambdaP)
            llfOptArr[y,i1,i2,i3] <- RSM_yFROC(
              z = x$minimum, 
              mu, 
              nuP = nuP)
          } else if (y == 2) {
            x <- optimize(Youden, 
                          interval = c(-5,5), 
                          mu, 
                          lambdaP = lambdaP, 
                          nuP = nuP, 
                          lesDistr)
            zetaOptArr[y,i1,i2,i3] <- x$minimum
            wAfrocArr[y,i1,i2,i3] <- UtilAnalyticalAucsRSM(
              mu, 
              lambdaP = lambdaP, 
              nuP = nuP, 
              zeta1 = x$minimum, 
              lesDistr, 
              relWeights)$aucwAFROC
            rocArr[y,i1,i2,i3] <- UtilAnalyticalAucsRSM(
              mu, 
              lambdaP = lambdaP, 
              nuP = nuP, 
              zeta1 = x$minimum, 
              lesDistr, 
              relWeights)$aucROC
            fpfOptArr[y,i1,i2,i3] <- RSM_xROC(
              z = x$minimum, 
              lambdaP = lambdaP)
            tpfOptArr[y,i1,i2,i3] <- RSM_yROC(
              z = x$minimum, 
              mu, 
              lambdaP = lambdaP,
              nuP = nuP,
              lesDistr = lesDistr)
            nlfOptArr[y,i1,i2,i3] <- RSM_xFROC(
              z = x$minimum, 
              lambdaP = lambdaP)
            llfOptArr[y,i1,i2,i3] <- RSM_yFROC(
              z = x$minimum, mu, nuP)
          } else stop("incorrect y")
        }
      }
    }
  }
  return(list(
    zetaOptArr = zetaOptArr,
    nlfOptArr = nlfOptArr,
    llfOptArr = llfOptArr,
    fpfOptArr = fpfOptArr,
    tpfOptArr = tpfOptArr,
    wAfrocArr = wAfrocArr, 
    rocArr = rocArr)
    )
}
```



```{r plot-froc, echo=FALSE}
plotFroc <- function(muArr, lambdaPArr, nuPArr) {
  plotArr <- array(list(), dim = 8)
  i <- 1
  for (i1 in 1:length(muArr)) {
    for (i2 in 1:length(lambdaPArr)) {
      for (i3 in 1:length(nuPArr)) {
        mu <- muArr[i1]
        lambdaP <- lambdaPArr[i2]
        nuP <- nuPArr[i3]
        z <- seq(-5,mu+5,0.1)
        xFROC <- RSM_xFROC(z, lambdaP)
        yFROC <- RSM_yFROC(z, mu, nuP)
        df_froc <- data.frame(
          NLF = xFROC, 
          LLF = yFROC)
        plotArr[[i]] <- ggplot2::ggplot(
          df_froc, 
          aes(x = NLF, y = LLF)) + 
          geom_line() +
          scale_x_continuous(limits = c(0,lambdaP)) + 
          scale_y_continuous(limits = c(0,1)) +
          ggtitle(paste0("mu = ", mu, ", nu = ", nuP, ", lambda = ", lambdaP))
        for (y in 1:2) {
          optPt <- data.frame(
            NLF = nlfOptArr[y,i1,i2,i3], 
            LLF = llfOptArr[y,i1,i2,i3])
          plotArr[[i]] <- plotArr[[i]] + 
            geom_point(data = optPt, color = y) 
        }
        i <- i + 1
      }
    }
  }
  return (plotArr)
}
```




```{r plot-wafroc, echo=FALSE}
plotwAfroc <- function(muArr, lambdaPArr, nuPArr, lesDistr, relWeights) {
  plotArr <- array(list(), dim = 8)
  i <- 1
  for (i1 in 1:length(muArr)) {
    for (i2 in 1:length(lambdaPArr)) {
      for (i3 in 1:length(nuPArr)) {
        mu <- muArr[i1]
        lambdaP <- lambdaPArr[i2]
        nuP <- nuPArr[i3]
        x <- UtilPhysical2IntrinsicRSM(mu, lambdaP = lambdaP, nuP = nuP)
        lambda <- x$lambda
        nu <- x$nu
        plotArr[[i]] <- PlotRsmOperatingCharacteristics(
          c(mu,mu),
          c(lambda,lambda),
          c(nu,nu),
          c(zetaOptArr[1,i1,i2,i3], zetaOptArr[2,i1,i2,i3]),
          lesDistr,
          relWeights,
          OpChType = "wAFROC",
          legendPosition = "null"
        )$wAFROCPlot +
          ggtitle(paste0("mu = ", mu, ", nu = ", nuP, ", lambda = ", lambdaP))
        i <- i + 1
      }
    }
  }
  return(plotArr)
}
```





```{r plot-roc, echo=FALSE}
plotRoc <- function(muArr, lambdaPArr, nuPArr, lesDistr, relWeights) {
  plotArr <- array(list(), dim = 8)
  i <- 1
  for (i1 in 1:length(muArr)) {
    for (i2 in 1:length(lambdaPArr)) {
      for (i3 in 1:length(nuPArr)) {
        mu <- muArr[i1]
        lambdaP <- lambdaPArr[i2]
        nuP <- nuPArr[i3]
        x <- UtilPhysical2IntrinsicRSM(mu, lambdaP = lambdaP, nuP = nuP)
        lambda <- x$lambda
        nu <- x$nu
        plotArr[[i]] <- PlotRsmOperatingCharacteristics(
          c(mu,mu),
          c(lambda,lambda),
          c(nu,nu),
          c(zetaOptArr[1,i1,i2,i3], zetaOptArr[2,i1,i2,i3]),
          lesDistr,
          relWeights,
          OpChType = "ROC",
          legendPosition = "null"
        )$ROCPlot +
          ggtitle(paste0("mu = ", mu, ", nu = ", nuP, ", lambda = ", lambdaP))
        i <- i + 1
      }
    }
  }
  return(plotArr)
}
```



```{r do-one-table, echo=FALSE}
doOneTable <- function(lambdaPArr, zetaOptArr, wAfrocArr, rocArr, nlfOptArr, llfOptArr, ind1,ind2,ind3, labelIndx) {
  if (labelIndx == 1) {
    x1 <- cbind(rep("wAFROC",4), mu = muArr, zeta1 = simplePrint(zetaOptArr[1,ind1,ind2,ind3]), wAFROC = simplePrint(wAfrocArr[1,ind1,ind2,ind3]), ROC = simplePrint(rocArr[1,ind1,ind2,ind3]), OptOpPt = OpPtStr(nlfOptArr[1,ind1,ind2,ind3], llfOptArr[1,ind1,ind2,ind3]))
    x2 <- cbind(rep("Youden",4), lambda = lambdaPArr, zeta1 = simplePrint(zetaOptArr[2,ind1,ind2,ind3]), wAFROC = simplePrint(wAfrocArr[2,ind1,ind2,ind3]), ROC = simplePrint(rocArr[2,ind1,ind2,ind3]), OptOpPt = OpPtStr(nlfOptArr[2,ind1,ind2,ind3], llfOptArr[2,ind1,ind2,ind3]))
    x12 <- as.data.frame(rbind(x1,x2))
    colnames(x12) <- c("FOM", "$\\mu$", "$\\zeta_1$", "$\\text{wAFROC}$", "$\\text{ROC}$", "$\\left( \\text{NLF}, \\text{LLF}\\right)$")
  } else if (labelIndx == 2) {
    x1 <- cbind(rep("wAFROC",4), lambda = lambdaPArr, zeta1 = simplePrint(zetaOptArr[1,ind1,ind2,ind3]), wAFROC = simplePrint(wAfrocArr[1,ind1,ind2,ind3]), ROC = simplePrint(rocArr[1,ind1,ind2,ind3]), OptOpPt = OpPtStr(nlfOptArr[1,ind1,ind2,ind3], llfOptArr[1,ind1,ind2,ind3]))
    x2 <- cbind(rep("Youden",4), lambda = lambdaPArr, zeta1 = simplePrint(zetaOptArr[2,ind1,ind2,ind3]), wAFROC = simplePrint(wAfrocArr[2,ind1,ind2,ind3]), ROC = simplePrint(rocArr[2,ind1,ind2,ind3]), OptOpPt = OpPtStr(nlfOptArr[2,ind1,ind2,ind3], llfOptArr[2,ind1,ind2,ind3]))
    x12 <- as.data.frame(rbind(x1,x2))
    colnames(x12) <- c("FOM", "$\\lambda$", "$\\zeta_1$", "$\\text{wAFROC}$", "$\\text{ROC}$", "$\\left( \\text{NLF}, \\text{LLF}\\right)$")
  } else if (labelIndx == 3) {
    x1 <- cbind(rep("wAFROC",4), nu = nuPArr, zeta1 = simplePrint(zetaOptArr[1,ind1,ind2,ind3]), wAFROC = simplePrint(wAfrocArr[1,ind1,ind2,ind3]), ROC = simplePrint(rocArr[1,ind1,ind2,ind3]), OptOpPt = OpPtStr(nlfOptArr[1,ind1,ind2,ind3], llfOptArr[1,ind1,ind2,ind3]))
    x2 <- cbind(rep("Youden",4), lambda = lambdaPArr, zeta1 = simplePrint(zetaOptArr[2,ind1,ind2,ind3]), wAFROC = simplePrint(wAfrocArr[2,ind1,ind2,ind3]), ROC = simplePrint(rocArr[2,ind1,ind2,ind3]), OptOpPt = OpPtStr(nlfOptArr[2,ind1,ind2,ind3], llfOptArr[2,ind1,ind2,ind3]))
    x12 <- as.data.frame(rbind(x1,x2))
    colnames(x12) <- c("FOM", "$\\nu$", "$\\zeta_1$", "$\\text{wAFROC}$", "$\\text{ROC}$", "$\\left( \\text{NLF}, \\text{LLF}\\right)$")
  } else stop("incorrect label index")
  return(x12)
}
```



## Appendix I: Varying $\nu$ optimizations{#optim-op-point-vary-nu}

For $\mu = 2$ and $\lambda = 1$ optimizations were performed for $\nu = 0.6, 0.7, 0.8, 0.9$. 




```{r}
muArr <- c(2)
lambdaPArr <- c(1)
nuPArr <- c(0.6, 0.7, 0.8, 0.9)
lesDistr <- c(0.5, 0.5)
relWeights <- c(0.5, 0.5)
```





```{r, echo = FALSE}
ret <- doOneSet(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
zetaOptArr <- ret$zetaOptArr
nlfOptArr <- ret$nlfOptArr
llfOptArr <- ret$llfOptArr
fpfOptArr <- ret$fpfOptArr
tpfOptArr <- ret$tpfOptArr
wAfrocArr <- ret$wAfrocArr
rocArr <- ret$rocArr
```




```{r optim-op-point-table-vary-nu-contents, echo=FALSE}
x12 <- doOneTable(lambdaPArr, zetaOptArr, wAfrocArr, rocArr, nlfOptArr, llfOptArr, 1,1,1:4, labelIndx = 3)
```




```{r optim-op-point-table-vary-nu, echo=FALSE}
kbl(x12, caption = "Summary of optimization results for $\\mu = 2$, $\\lambda = 1$ and 4 values of $\\nu$.", booktabs = TRUE, escape = FALSE) %>% collapse_rows(columns = c(1), valign = "middle") %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```



Table \@ref(tab:optim-op-point-table-vary-nu) summarizes the results.

1. For wAFROC-AUC FOM as $\nu$ increases the optimal threshold *decreases* and both $\text{wAFROC} \left ( 1, \mu, \lambda, \nu \right )$ and $\text{ROC} \left ( 1, \mu, \lambda, \nu \right )$ *increase*. CAD performance increases, regardless of how it is measured. Performance increases with increasing numbers of LLs per case and this effect is reinforced by performance going up with decreasing optimal reporting threshold. [Since both $\text{LLF} \left ( f, \mu, \lambda, \nu \right )$ and $\text{NLF} \left ( f, \mu, \lambda, \nu \right )$ increase with increasing $\nu$, neither FROC-curve based measure has an unambiguous interpretation.  

1. The wAFROC based based optimal thresholds are smaller than the corresponding Youden-index based optimal thresholds, i.e., $\zeta_{1} \left ( 1, \mu, \lambda, \nu \right ) < \zeta_{1} \left ( 2, \mu, \lambda, \nu \right )$. A smaller threshold corresponds to a less strict reporting criterion.

1. For fixed $\mu, \lambda, \nu$ the operating point on the FROC for $f = 2$ is below that corresponding to $f = 1$:
    + $\text{NLF} \left (2, \mu, \lambda, \nu \right ) < \text{NLF} \left (1, \mu, \lambda, \nu \right )$ and 
    + $\text{LLF} \left (2, \mu, \lambda, \nu \right ) < \text{LLF} \left (1, \mu, \lambda, \nu \right )$. 
    + The difference increases with increasing $\nu$. 
    + These effects are illustrated in Fig. \@ref(fig:optim-op-point-vary-nu-froc).

1. For fixed $\mu, \lambda, \nu$ the Youden-index based optimization yields lesser performance than the corresponding wAFROC-AUC based optimization:

    + $\text{wAFROC} \left (2, \mu, \lambda, \nu \right ) < \text{wAFROC} \left (1, \mu, \lambda, \nu \right )$ and 
    + $\text{ROC} \left (2, \mu, \lambda, \nu \right ) < \text{ROC} \left (1, \mu, \lambda, \nu \right )$. 
    + The difference decreases with decreasing $\nu$. 
    + These effects are illustrated in Fig. \@ref(fig:optim-op-point-vary-nu-wafroc).


The third effect is illustrated by the FROC plots with superimposed operating points for varying $\nu$ shown in Fig. \@ref(fig:optim-op-point-vary-nu-froc). The black dots are consistently above the red dots and the separation of the dots is greatest for $\nu = 0.9$ and smallest for $\nu = 0.6$. The difference in optimal thresholds found by the two optimization methods is greatest for poor performance.  

The FROC plots also illustrate the decrease in $\text{LLF} \left ( f, \mu, \lambda, \nu \right )$ with increasing $\nu$ (the black dots move to larger ordinates, as do the red dots). However, the accompanying change in $\text{NLF} \left ( f, \mu, \lambda, \nu \right )$ rules out an FROC curve based unambiguous determination of the direction of the change in overall performance. 



 
```{r echo=FALSE}
plotArr = plotFroc(muArr, lambdaPArr, nuPArr)
```




```{r optim-op-point-vary-nu-froc, fig.cap = "FROC plots with superimposed operating points for varying $\\nu$. The black dot corresponds to wAFROC AUC optimization and the red dot to Youden-index optimization.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
```




 
```{r echo=FALSE}
plotArr = plotwAfroc(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
```






```{r optim-op-point-vary-nu-wafroc, fig.cap="wAFROC plots for the two optimization methods. The color coding is as in previous figures.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
```





```{r echo=FALSE}
plotArr = plotRoc(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
```







```{r optim-op-point-vary-nu-roc, fig.cap="ROC plots for the two optimization methods. The color coding is as in previous figures.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
```





## Appendix II: Varying $\mu$ optimizations{#optim-op-point-vary-mu}

For $\lambda = 1$ and $\nu = 0.9$ optimizations were performed for $\mu = 1, 2, 3, 4$. 



```{r}
muArr <- c(1, 2, 3, 4)
lambdaPArr <- 1
nuPArr <- 0.9
lesDistr <- c(0.5, 0.5)
relWeights <- c(0.5, 0.5)
```





```{r, echo = FALSE}
ret <- doOneSet(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
zetaOptArr <- ret$zetaOptArr
nlfOptArr <- ret$nlfOptArr
llfOptArr <- ret$llfOptArr
fpfOptArr <- ret$fpfOptArr
tpfOptArr <- ret$tpfOptArr
wAfrocArr <- ret$wAfrocArr
rocArr <- ret$rocArr
```







```{r optim-op-point-table-vary-mu-contents, echo=FALSE}
x12 <- doOneTable(lambdaPArr, zetaOptArr, wAfrocArr, rocArr, nlfOptArr, llfOptArr, 1:4,1,1, labelIndx = 1)
```




```{r optim-op-point-table-vary-mu, echo=FALSE}
kbl(x12, caption = "Summary of optimization results for $\\lambda = 1$, $\\nu = 0.9$  and 4 values of $\\mu$.", booktabs = TRUE, escape = FALSE) %>% collapse_rows(columns = c(1), valign = "middle") %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```



Table \@ref(tab:optim-op-point-table-vary-mu) summarizes the results.

1. For either FOM as $\mu$ increases the optimal threshold *increases* and both $\text{wAFROC} \left ( f, \mu, \lambda, \nu \right )$ and $\text{ROC} \left ( f, \mu, \lambda, \nu \right )$ *increase*. CAD performance increases, regardless of how it is measured. Performance increases with increasing separation of the sampling distributions of NLs and LLs and the negative effect of increasing optimal reporting thresholds is not enough to overcome this. [Since $\text{LLF} \left ( f, \mu, \lambda, \nu \right )$ is relatively constant while $\text{NLF} \left ( f, \mu, \lambda, \nu \right )$ decreases sharply with increasing $\mu$, this is one example where an FROC-curve based measure does have an unambiguous interpretation, namely performance is higher for the larger values of $\mu$.  

1. The wAFROC based based optimal thresholds are smaller than the corresponding Youden-index based optimal thresholds. A smaller threshold corresponds to a less strict reporting criterion and greater wAFROC-AUC and ROC-AUC performance.

1. For fixed $\mu, \lambda, \nu$ the operating point on the FROC for $f = 2$ is below that corresponding to $f = 1$. The difference decreases with increasing $\mu$. These effects are illustrated in Fig. \@ref(fig:optim-op-point-vary-mu-froc). The black dots are consistently above the red dots and the separation of the dots is greatest for $\mu = 1$ and smallest for $\mu = 4$.  


1. For fixed $\mu, \lambda, \nu$ the Youden-index based optimization yields lesser performance than the corresponding wAFROC-AUC based optimization. The difference decreases with increasing $\mu$. These effects are illustrated in Fig. \@ref(fig:optim-op-point-vary-mu-wafroc).



```{r echo=FALSE}
plotArr = plotFroc(muArr, lambdaPArr, nuPArr)
```





```{r optim-op-point-vary-mu-froc, fig.cap = "FROC plots with superimposed operating points for varying $\\mu$. The black dot corresponds to wAFROC AUC optimization and the red dot to Youden-index optimization.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
```




```{r echo=FALSE}
plotArr = plotwAfroc(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
```







```{r optim-op-point-vary-mu-wafroc, fig.cap="wAFROC plots for the two optimization methods. The color coding is as in previous figures.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
```



TBA The continuous section of each curve ends at the optimal threshold listed in Table \@ref(tab:optim-op-point-table-vary-mu), namely $\zeta_1$ = `r simplePrint(zetaOptArr[1,1,1,1])` for the green-red-red-dashed curve and $\zeta_1$ = `r simplePrint(zetaOptArr[2,1,1,1])` for the green curve. The lower performance represented by the green curve, based on Youden-index maximization, is due to the adoption of an overly strict threshold.




```{r echo=FALSE}
plotArr = plotRoc(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
```








```{r optim-op-point-vary-mu-roc, fig.cap="ROC plots for the two optimization methods. The color coding is as in previous figures.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
```


The continuous section of each curve ends at the optimal threshold listed in Table \@ref(tab:optim-op-point-table-vary-mu). The lower performance represented by the green curve, based on Youden-index maximization, is due to the adoption of an overly strict threshold.





## Appendix III: Limiting situations {#optim-op-point-limiting-situations}

### High performance vary mu {#optim-op-point-high-performance-vary-mu}


```{r}
muArr <- c(3, 4, 5, 6)
nuPArr <- c(0.9)
lambdaPArr <- c(1)
lesDistr <- c(0.5, 0.5)
relWeights <- c(0.5, 0.5)
```




```{r, echo = FALSE}
ret <- doOneSet(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
zetaOptArr <- ret$zetaOptArr
nlfOptArr <- ret$nlfOptArr
llfOptArr <- ret$llfOptArr
fpfOptArr <- ret$fpfOptArr
tpfOptArr <- ret$tpfOptArr
wAfrocArr <- ret$wAfrocArr
rocArr <- ret$rocArr
```



```{r optim-op-point-high-performance-vary-mu-table-vary-all-contents, echo=FALSE}
x1 <- expand.grid(FOM = c("wAFROC", "Youden"), mu = muArr, lambda = lambdaPArr, nu = nuPArr)
x1 <- cbind(x1, zeta1 = simplePrint(zetaOptArr[,,1,1]), wAFROC = simplePrint(wAfrocArr[,,1,1]), AUC = simplePrint(rocArr[,,1,1]), Sp = simplePrint(1-fpfOptArr[,,1,1]), Se = simplePrint(tpfOptArr[,,1,1]))
colnames(x1) <- c("FOM", "$\\mu$", "$\\lambda$", "$\\nu$", "$\\zeta_1$", "wAFROC", "ROC", "Sp", "Se")
```



```{r optim-op-point-high-performance-vary-mu-table-vary-all, echo=FALSE}
kbl(x1, caption = "Summary of optimizations for combinations of levels of $\\mu$, $\\lambda$ and $\\nu$ parameters. FOM = figure of merit, $\\zeta_1$ = threshold that optimizes FOM, wAFROC = wAFROC-AUC, ROC = ROC-AUC, Sp = specificity and Se = sensitivity.", booktabs = TRUE, escape = FALSE) %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```





```{r echo=FALSE}
plotArr = plotFroc(muArr, lambdaPArr, nuPArr)
```






```{r optim-op-point-high-performance-vary-mu-vary-all-froc, fig.cap = "FROC plots with superimposed operating points for varying $\\nu$. The black dot corresponds to wAFROC AUC optimization and the red dot to Youden-index optimization.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
#grid.arrange(plotArr[[5]], plotArr[[6]], plotArr[[7]], plotArr[[8]], nrow = 2, ncol = 2)
```







```{r echo=FALSE}
plotArr = plotwAfroc(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
```



```{r optim-op-point-high-performance-vary-mu-vary-all-wafroc, fig.cap="wAFROC plots for the two optimization methods. The color coding is as in previous figures.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
#grid.arrange(plotArr[[5]], plotArr[[6]], plotArr[[7]], plotArr[[8]], nrow = 2, ncol = 2)
```







```{r echo=FALSE}
plotArr = plotRoc(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
```




```{r optim-op-point-high-performance-vary-mu-vary-all-roc, fig.cap="ROC plots for the two optimization methods. The color coding is as in previous figures.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
#grid.arrange(plotArr[[5]], plotArr[[6]], plotArr[[7]], plotArr[[8]], nrow = 2, ncol = 2)
```


### Low performance vary mu {#optim-op-point-low-performance-vary-mu}


```{r}
muArr <- c(1, 2, 3, 4)
nuPArr <- c(0.1)
lambdaPArr <- c(10)
lesDistr <- c(0.5, 0.5)
relWeights <- c(0.5, 0.5)
```





```{r, echo = FALSE}
ret <- doOneSet(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
zetaOptArr <- ret$zetaOptArr
nlfOptArr <- ret$nlfOptArr
llfOptArr <- ret$llfOptArr
fpfOptArr <- ret$fpfOptArr
tpfOptArr <- ret$tpfOptArr
wAfrocArr <- ret$wAfrocArr
rocArr <- ret$rocArr
```





```{r optim-op-point-low-performance-vary-mu-table-vary-all-contents, echo=FALSE}
x1 <- expand.grid(FOM = c("wAFROC", "Youden"), mu = muArr, lambda = lambdaPArr, nu = nuPArr)
x1 <- cbind(x1, zeta1 = simplePrint(zetaOptArr), wAFROC = simplePrint(wAfrocArr), AUC = simplePrint(rocArr), Sp = simplePrint(1-fpfOptArr), Se = simplePrint(tpfOptArr))
colnames(x1) <- c("FOM", "$\\mu$", "$\\lambda$", "$\\nu$", "$\\zeta_1$", "wAFROC", "ROC", "Sp", "Se")
```



```{r optim-op-point-low-performance-vary-mu-table-vary-all, echo=FALSE}
kbl(x1, caption = "Summary of optimizations for combinations of levels of $\\mu$, $\\lambda$ and $\\nu$ parameters. FOM = figure of merit, $\\zeta_1$ = threshold that optimizes FOM, wAFROC = wAFROC-AUC, ROC = ROC-AUC, Sp = specificity and Se = sensitivity.", booktabs = TRUE, escape = FALSE) %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```






```{r echo=FALSE}
plotArr = plotFroc(muArr, lambdaPArr, nuPArr)
```




```{r optim-op-point-low-performance-vary-mu-vary-all-froc, fig.cap = "FROC plots with superimposed operating points for varying $\\nu$. The black dot corresponds to wAFROC AUC optimization and the red dot to Youden-index optimization.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
#grid.arrange(plotArr[[5]], plotArr[[6]], plotArr[[7]], plotArr[[8]], nrow = 2, ncol = 2)
```



```{r, echo=FALSE}
plotArr <- array(list(), dim = 8)
i <- 1
for (i1 in 1:length(muArr)) {
  for (i2 in 1:length(lambdaPArr)) {
    for (i3 in 1:length(nuPArr)) {
      mu <- muArr[i1]
      lambdaP <- lambdaPArr[i2]
      nuP <- nuPArr[i3]
      x <- UtilPhysical2IntrinsicRSM(mu, lambdaP = lambdaP, nuP = nuP)
      lambda <- x$lambda
      nu <- x$nu
      plotArr[[i]] <- PlotRsmOperatingCharacteristics(
        c(mu,mu),
        c(lambda,lambda),
        c(nu,nu),
        c(zetaOptArr[1,i1,i2,i3], zetaOptArr[2,i1,i2,i3]),
        lesDistr,
        relWeights,
        OpChType = "wAFROC",
        legendPosition = "null"
      )$wAFROCPlot +
        ggtitle(paste0("mu = ", mu, ", nu = ", nuP, ", lambda = ", lambdaP))
      i <- i + 1
    }
  }
}
```





```{r echo=FALSE}
plotArr = plotwAfroc(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
```



```{r optim-op-point-low-performance-vary-mu-vary-all-wafroc, fig.cap="wAFROC plots for the two optimization methods. The color coding is as in previous figures.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
#grid.arrange(plotArr[[5]], plotArr[[6]], plotArr[[7]], plotArr[[8]], nrow = 2, ncol = 2)
```



```{r echo=FALSE}
plotArr = plotRoc(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
```




```{r optim-op-point-low-performance-vary-mu-vary-all-roc, fig.cap="ROC plots for the two optimization methods. The color coding is as in previous figures.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
#grid.arrange(plotArr[[5]], plotArr[[6]], plotArr[[7]], plotArr[[8]], nrow = 2, ncol = 2)
```




### High performance vary lambda {#optim-op-point-high-performance-vary-lambda}


```{r}
muArr <- c(5)
nuPArr <- c(0.9)
lambdaPArr <- c(1,2,5,10)
lesDistr <- c(0.5, 0.5)
relWeights <- c(0.5, 0.5)
```




```{r, echo = FALSE}
ret <- doOneSet(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
zetaOptArr <- ret$zetaOptArr
nlfOptArr <- ret$nlfOptArr
llfOptArr <- ret$llfOptArr
fpfOptArr <- ret$fpfOptArr
tpfOptArr <- ret$tpfOptArr
wAfrocArr <- ret$wAfrocArr
rocArr <- ret$rocArr
```







```{r optim-op-point-high-performance-vary-lambda-table-vary-all-contents, echo=FALSE}
x1 <- expand.grid(FOM = c("wAFROC", "Youden"), mu = muArr, lambda = lambdaPArr, nu = nuPArr)
x1 <- cbind(x1, zeta1 = simplePrint(zetaOptArr), wAFROC = simplePrint(wAfrocArr), AUC = simplePrint(rocArr), Sp = simplePrint(1-fpfOptArr), Se = simplePrint(tpfOptArr))
colnames(x1) <- c("FOM", "$\\mu$", "$\\lambda$", "$\\nu$", "$\\zeta_1$", "wAFROC", "ROC", "Sp", "Se")
```



```{r optim-op-point-high-performance-vary-lambda-table-vary-all, echo=FALSE}
kbl(x1, caption = "Summary of optimizations for combinations of levels of $\\mu$, $\\lambda$ and $\\nu$ parameters. FOM = figure of merit, $\\zeta_1$ = threshold that optimizes FOM, wAFROC = wAFROC-AUC, ROC = ROC-AUC, Sp = specificity and Se = sensitivity.", booktabs = TRUE, escape = FALSE) %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```





```{r echo=FALSE}
plotArr = plotFroc(muArr, lambdaPArr, nuPArr)
```



```{r optim-op-point-high-performance-vary-lambda-vary-all-froc, fig.cap = "FROC plots with superimposed operating points for varying $\\nu$. The black dot corresponds to wAFROC AUC optimization and the red dot to Youden-index optimization.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
#grid.arrange(plotArr[[5]], plotArr[[6]], plotArr[[7]], plotArr[[8]], nrow = 2, ncol = 2)
```




```{r echo=FALSE}
plotArr = plotwAfroc(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
```






```{r optim-op-point-high-performance-vary-lambda-vary-all-wafroc, fig.cap="wAFROC plots for the two optimization methods. The color coding is as in previous figures.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
#grid.arrange(plotArr[[5]], plotArr[[6]], plotArr[[7]], plotArr[[8]], nrow = 2, ncol = 2)
```




```{r echo=FALSE}
plotArr = plotRoc(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
```




```{r optim-op-point-high-performance-vary-lambda-vary-all-roc, fig.cap="ROC plots for the two optimization methods. The color coding is as in previous figures.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
#grid.arrange(plotArr[[5]], plotArr[[6]], plotArr[[7]], plotArr[[8]], nrow = 2, ncol = 2)
```


### Low performance vary lambda  {#optim-op-point-low-performance-vary-lambda}


```{r}
muArr <- c(1)
nuPArr <- c(0.2)
lambdaPArr <- c(1, 2, 5, 10)
lesDistr <- c(0.5, 0.5)
relWeights <- c(0.5, 0.5)
```




```{r, echo = FALSE}
ret <- doOneSet(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
zetaOptArr <- ret$zetaOptArr
nlfOptArr <- ret$nlfOptArr
llfOptArr <- ret$llfOptArr
fpfOptArr <- ret$fpfOptArr
tpfOptArr <- ret$tpfOptArr
wAfrocArr <- ret$wAfrocArr
rocArr <- ret$rocArr
```






```{r optim-op-point-low-performance-vary-lambda-table-vary-all-contents, echo=FALSE}
x1 <- expand.grid(FOM = c("wAFROC", "Youden"), mu = muArr, lambda = lambdaPArr, nu = nuPArr)
x1 <- cbind(x1, zeta1 = simplePrint(zetaOptArr), wAFROC = simplePrint(wAfrocArr), AUC = simplePrint(rocArr), Sp = simplePrint(1-fpfOptArr), Se = simplePrint(tpfOptArr))
colnames(x1) <- c("FOM", "$\\mu$", "$\\lambda$", "$\\nu$", "$\\zeta_1$", "wAFROC", "ROC", "Sp", "Se")
```



```{r optim-op-point-low-performance-vary-lambda-table-vary-all, echo=FALSE}
kbl(x1, caption = "Summary of optimizations for combinations of levels of $\\mu$, $\\lambda$ and $\\nu$ parameters. FOM = figure of merit, $\\zeta_1$ = threshold that optimizes FOM, wAFROC = wAFROC-AUC, ROC = ROC-AUC, Sp = specificity and Se = sensitivity.", booktabs = TRUE, escape = FALSE) %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```




```{r echo=FALSE}
plotArr = plotFroc(muArr, lambdaPArr, nuPArr)
```




```{r optim-op-point-low-performance-vary-lambda-vary-all-froc, fig.cap = "FROC plots with superimposed operating points for varying $\\nu$. The black dot corresponds to wAFROC AUC optimization and the red dot to Youden-index optimization.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
#grid.arrange(plotArr[[5]], plotArr[[6]], plotArr[[7]], plotArr[[8]], nrow = 2, ncol = 2)
```




```{r echo=FALSE}
plotArr = plotwAfroc(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
```







```{r optim-op-point-low-performance-vary-lambda-vary-all-wafroc, fig.cap="wAFROC plots for the two optimization methods. The color coding is as in previous figures.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
#grid.arrange(plotArr[[5]], plotArr[[6]], plotArr[[7]], plotArr[[8]], nrow = 2, ncol = 2)
```




```{r echo=FALSE}
plotArr = plotRoc(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
```




```{r optim-op-point-low-performance-vary-lambda-vary-all-roc, fig.cap="ROC plots for the two optimization methods. The color coding is as in previous figures.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
#grid.arrange(plotArr[[5]], plotArr[[6]], plotArr[[7]], plotArr[[8]], nrow = 2, ncol = 2)
```



### High performance vary nu {#optim-op-point-high-performance-vary-nu}


```{r}
muArr <- c(4)
lambdaPArr <- c(1)
nuPArr <- c(0.3, 0.5, 0.7, 0.9)
lesDistr <- c(0.5, 0.5)
relWeights <- c(0.5, 0.5)
```




```{r, echo = FALSE}
ret <- doOneSet(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
zetaOptArr <- ret$zetaOptArr
nlfOptArr <- ret$nlfOptArr
llfOptArr <- ret$llfOptArr
fpfOptArr <- ret$fpfOptArr
tpfOptArr <- ret$tpfOptArr
wAfrocArr <- ret$wAfrocArr
rocArr <- ret$rocArr
```






```{r optim-op-point-high-performance-vary-nu-table-vary-all-contents, echo=FALSE}
x1 <- expand.grid(FOM = c("wAFROC", "Youden"), mu = muArr, lambda = lambdaPArr, nu = nuPArr)
x1 <- cbind(x1, zeta1 = simplePrint(zetaOptArr), wAFROC = simplePrint(wAfrocArr), AUC = simplePrint(rocArr), Sp = simplePrint(1-fpfOptArr), Se = simplePrint(tpfOptArr))
colnames(x1) <- c("FOM", "$\\mu$", "$\\lambda$", "$\\nu$", "$\\zeta_1$", "wAFROC", "ROC", "Sp", "Se")
```



```{r optim-op-point-high-performance-vary-nu-table-vary-all, echo=FALSE}
kbl(x1, caption = "Summary of optimizations for combinations of levels of $\\mu$, $\\lambda$ and $\\nu$ parameters. FOM = figure of merit, $\\zeta_1$ = threshold that optimizes FOM, wAFROC = wAFROC-AUC, ROC = ROC-AUC, Sp = specificity and Se = sensitivity.", booktabs = TRUE, escape = FALSE) %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```





```{r echo=FALSE}
plotArr = plotFroc(muArr, lambdaPArr, nuPArr)
```




```{r optim-op-point-high-performance-vary-nu-vary-all-froc, fig.cap = "FROC plots with superimposed operating points for varying $\\nu$. The black dot corresponds to wAFROC AUC optimization and the red dot to Youden-index optimization.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
#grid.arrange(plotArr[[5]], plotArr[[6]], plotArr[[7]], plotArr[[8]], nrow = 2, ncol = 2)
```





```{r echo=FALSE}
plotArr = plotwAfroc(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
```






```{r optim-op-point-high-performance-vary-nu-vary-all-wafroc, fig.cap="wAFROC plots for the two optimization methods. The color coding is as in previous figures.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
#grid.arrange(plotArr[[5]], plotArr[[6]], plotArr[[7]], plotArr[[8]], nrow = 2, ncol = 2)
```





```{r echo=FALSE}
plotArr = plotRoc(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
```




```{r optim-op-point-high-performance-vary-nu-vary-all-roc, fig.cap="ROC plots for the two optimization methods. The color coding is as in previous figures.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
#grid.arrange(plotArr[[5]], plotArr[[6]], plotArr[[7]], plotArr[[8]], nrow = 2, ncol = 2)
```


### Low performance vary nu {#optim-op-point-low-performance-vary-nu}


```{r}
muArr <- c(1)
lambdaPArr <- c(10)
nuPArr <- c(0.3, 0.5, 0.7, 0.9)
lesDistr <- c(0.5, 0.5)
relWeights <- c(0.5, 0.5)
```




```{r, echo = FALSE}
ret <- doOneSet(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
zetaOptArr <- ret$zetaOptArr
nlfOptArr <- ret$nlfOptArr
llfOptArr <- ret$llfOptArr
fpfOptArr <- ret$fpfOptArr
tpfOptArr <- ret$tpfOptArr
wAfrocArr <- ret$wAfrocArr
rocArr <- ret$rocArr
```






```{r optim-op-point-low-performance-vary-nu-table-vary-all-contents, echo=FALSE}
x1 <- expand.grid(FOM = c("wAFROC", "Youden"), mu = muArr, lambda = lambdaPArr, nu = nuPArr)
x1 <- cbind(x1, zeta1 = simplePrint(zetaOptArr), wAFROC = simplePrint(wAfrocArr), AUC = simplePrint(rocArr), Sp = simplePrint(1-fpfOptArr), Se = simplePrint(tpfOptArr))
colnames(x1) <- c("FOM", "$\\mu$", "$\\lambda$", "$\\nu$", "$\\zeta_1$", "wAFROC", "ROC", "Sp", "Se")
```



```{r optim-op-point-low-performance-vary-nu-table-vary-all, echo=FALSE}
kbl(x1, caption = "Summary of optimizations for combinations of levels of $\\mu$, $\\lambda$ and $\\nu$ parameters. FOM = figure of merit, $\\zeta_1$ = threshold that optimizes FOM, wAFROC = wAFROC-AUC, ROC = ROC-AUC, Sp = specificity and Se = sensitivity.", booktabs = TRUE, escape = FALSE) %>% kable_styling(latex_options = c("basic", "scale_down", "HOLD_position"), row_label_position = "c") 
```




```{r echo=FALSE}
plotArr = plotFroc(muArr, lambdaPArr, nuPArr)
```




```{r optim-op-point-low-performance-vary-nu-vary-all-froc, fig.cap = "FROC plots with superimposed operating points for varying $\\nu$. The black dot corresponds to wAFROC AUC optimization and the red dot to Youden-index optimization.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
#grid.arrange(plotArr[[5]], plotArr[[6]], plotArr[[7]], plotArr[[8]], nrow = 2, ncol = 2)
```




```{r echo=FALSE}
plotArr = plotwAfroc(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
```







```{r optim-op-point-low-performance-vary-nu-vary-all-wafroc, fig.cap="wAFROC plots for the two optimization methods. The color coding is as in previous figures.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
#grid.arrange(plotArr[[5]], plotArr[[6]], plotArr[[7]], plotArr[[8]], nrow = 2, ncol = 2)
```




```{r echo=FALSE}
plotArr = plotRoc(muArr, lambdaPArr, nuPArr, lesDistr, relWeights)
```




```{r optim-op-point-low-performance-vary-nu-vary-all-roc, fig.cap="ROC plots for the two optimization methods. The color coding is as in previous figures.", fig.show='hold', echo=FALSE}
grid.arrange(plotArr[[1]], plotArr[[2]], plotArr[[3]], plotArr[[4]], nrow = 2, ncol = 2)
#grid.arrange(plotArr[[5]], plotArr[[6]], plotArr[[7]], plotArr[[8]], nrow = 2, ncol = 2)
```



## References {#optim-op-point-references2}
